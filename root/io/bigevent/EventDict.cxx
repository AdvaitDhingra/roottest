//
// File generated by rootcint at Tue Jun  8 14:54:23 2004.
// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h"
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

#include "EventDict.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;

#include "RtypesImp.h"

#include "TVectorProxy.h"

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::template1< int > template1lEintgR;
      #else
      class template1lEintgR  {
         public:
         //friend XX;
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::template2< ::template1< int >  > template2lEtemplate1lEintgRsPgR;
      #else
      class template2lEtemplate1lEintgRsPgR  {
         public:
         //friend XX;
      };
      #endif

   } // Of namespace ROOT::Shadow
} // Of namespace ROOT

namespace ROOT {
   void UShortVector_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static TClass *UShortVector_IsA(const void*);
   static void *new_UShortVector(void *p = 0);
   static void *newArray_UShortVector(Long_t size);
   static void delete_UShortVector(void *p);
   static void deleteArray_UShortVector(void *p);
   static void destruct_UShortVector(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const UShortVector*)
   {
      UShortVector *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("UShortVector", UShortVector::Class_Version(), "Event.h", 36,
                  typeid(UShortVector), DefineBehavior(ptr, ptr),
                  &::UShortVector::Dictionary, &UShortVector_IsA, 4,
                  sizeof(UShortVector) );
      instance.SetNew(&new_UShortVector);
      instance.SetNewArray(&newArray_UShortVector);
      instance.SetDelete(&delete_UShortVector);
      instance.SetDeleteArray(&deleteArray_UShortVector);
      instance.SetDestructor(&destruct_UShortVector);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const UShortVector*)0x0); R__UseDummy(_R__UNIQUE_(Init));
}

namespace ROOT {
   void EventHeader_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static TClass *EventHeader_IsA(const void*);
   static void *new_EventHeader(void *p = 0);
   static void *newArray_EventHeader(Long_t size);
   static void delete_EventHeader(void *p);
   static void deleteArray_EventHeader(void *p);
   static void destruct_EventHeader(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const EventHeader*)
   {
      EventHeader *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("EventHeader", EventHeader::Class_Version(), "Event.h", 49,
                  typeid(EventHeader), DefineBehavior(ptr, ptr),
                  &::EventHeader::Dictionary, &EventHeader_IsA, 4,
                  sizeof(EventHeader) );
      instance.SetNew(&new_EventHeader);
      instance.SetNewArray(&newArray_EventHeader);
      instance.SetDelete(&delete_EventHeader);
      instance.SetDeleteArray(&deleteArray_EventHeader);
      instance.SetDestructor(&destruct_EventHeader);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const EventHeader*)0x0); R__UseDummy(_R__UNIQUE_(Init));
}

namespace ROOT {
   void Event_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static TClass *Event_IsA(const void*);
   static void *new_Event(void *p = 0);
   static void *newArray_Event(Long_t size);
   static void delete_Event(void *p);
   static void deleteArray_Event(void *p);
   static void destruct_Event(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const Event*)
   {
      Event *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("Event", Event::Class_Version(), "Event.h", 76,
                  typeid(Event), DefineBehavior(ptr, ptr),
                  &::Event::Dictionary, &Event_IsA, 4,
                  sizeof(Event) );
      instance.SetNew(&new_Event);
      instance.SetNewArray(&newArray_Event);
      instance.SetDelete(&delete_Event);
      instance.SetDeleteArray(&deleteArray_Event);
      instance.SetDestructor(&destruct_Event);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const Event*)0x0); R__UseDummy(_R__UNIQUE_(Init));
}

namespace ROOT {
   void template1lEintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void template1lEintgR_Dictionary();
   static TClass *template1lEintgR_IsA(const void*);
   static void *new_template1lEintgR(void *p = 0);
   static void *newArray_template1lEintgR(Long_t size);
   static void delete_template1lEintgR(void *p);
   static void deleteArray_template1lEintgR(void *p);
   static void destruct_template1lEintgR(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const template1<int>*)
   {
      // Make sure the shadow class has the right sizeof
      Assert(sizeof(::template1<int>) == sizeof(ROOT::Shadow::template1lEintgR));
      template1<int> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("template1<int>", "Event.h", 73,
                  typeid(template1<int>), DefineBehavior(ptr, ptr),
                  (void*)&template1lEintgR_ShowMembers, &template1lEintgR_Dictionary, &template1lEintgR_IsA, 4,
                  sizeof(template1<int>) );
      instance.SetNew(&new_template1lEintgR);
      instance.SetNewArray(&newArray_template1lEintgR);
      instance.SetDelete(&delete_template1lEintgR);
      instance.SetDeleteArray(&deleteArray_template1lEintgR);
      instance.SetDestructor(&destruct_template1lEintgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const template1<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void template1lEintgR_Dictionary() {
      ROOT::GenerateInitInstance((const template1<int>*)0x0)->GetClass();
   }

}

namespace ROOT {
   void template2lEtemplate1lEintgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void template2lEtemplate1lEintgRsPgR_Dictionary();
   static TClass *template2lEtemplate1lEintgRsPgR_IsA(const void*);
   static void *new_template2lEtemplate1lEintgRsPgR(void *p = 0);
   static void *newArray_template2lEtemplate1lEintgRsPgR(Long_t size);
   static void delete_template2lEtemplate1lEintgRsPgR(void *p);
   static void deleteArray_template2lEtemplate1lEintgRsPgR(void *p);
   static void destruct_template2lEtemplate1lEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const template2<template1<int> >*)
   {
      // Make sure the shadow class has the right sizeof
      Assert(sizeof(::template2<template1<int> >) == sizeof(ROOT::Shadow::template2lEtemplate1lEintgRsPgR));
      template2<template1<int> > *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("template2<template1<int> >", "Event.h", 74,
                  typeid(template2<template1<int> >), DefineBehavior(ptr, ptr),
                  (void*)&template2lEtemplate1lEintgRsPgR_ShowMembers, &template2lEtemplate1lEintgRsPgR_Dictionary, &template2lEtemplate1lEintgRsPgR_IsA, 4,
                  sizeof(template2<template1<int> >) );
      instance.SetNew(&new_template2lEtemplate1lEintgRsPgR);
      instance.SetNewArray(&newArray_template2lEtemplate1lEintgRsPgR);
      instance.SetDelete(&delete_template2lEtemplate1lEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_template2lEtemplate1lEintgRsPgR);
      instance.SetDestructor(&destruct_template2lEtemplate1lEintgRsPgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const template2<template1<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void template2lEtemplate1lEintgRsPgR_Dictionary() {
      ROOT::GenerateInitInstance((const template2<template1<int> >*)0x0)->GetClass();
   }

}

namespace ROOT {
   void Track_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static TClass *Track_IsA(const void*);
   static void *new_Track(void *p = 0);
   static void *newArray_Track(Long_t size);
   static void delete_Track(void *p);
   static void deleteArray_Track(void *p);
   static void destruct_Track(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const Track*)
   {
      Track *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("Track", Track::Class_Version(), "Event.h", 185,
                  typeid(Track), DefineBehavior(ptr, ptr),
                  &::Track::Dictionary, &Track_IsA, 4,
                  sizeof(Track) );
      instance.SetNew(&new_Track);
      instance.SetNewArray(&newArray_Track);
      instance.SetDelete(&delete_Track);
      instance.SetDeleteArray(&deleteArray_Track);
      instance.SetDestructor(&destruct_Track);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const Track*)0x0); R__UseDummy(_R__UNIQUE_(Init));
}

namespace ROOT {
   void BigTrack_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static TClass *BigTrack_IsA(const void*);
   static void *new_BigTrack(void *p = 0);
   static void *newArray_BigTrack(Long_t size);
   static void delete_BigTrack(void *p);
   static void deleteArray_BigTrack(void *p);
   static void destruct_BigTrack(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const BigTrack*)
   {
      BigTrack *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("BigTrack", BigTrack::Class_Version(), "Event.h", 243,
                  typeid(BigTrack), DefineBehavior(ptr, ptr),
                  &::BigTrack::Dictionary, &BigTrack_IsA, 4,
                  sizeof(BigTrack) );
      instance.SetNew(&new_BigTrack);
      instance.SetNewArray(&newArray_BigTrack);
      instance.SetDelete(&delete_BigTrack);
      instance.SetDeleteArray(&deleteArray_BigTrack);
      instance.SetDestructor(&destruct_BigTrack);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const BigTrack*)0x0); R__UseDummy(_R__UNIQUE_(Init));
}

namespace ROOT {
   void HistogramManager_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static TClass *HistogramManager_IsA(const void*);
   static void delete_HistogramManager(void *p);
   static void deleteArray_HistogramManager(void *p);
   static void destruct_HistogramManager(void *p);

   // Function generating the singleton type initializer
   TGenericClassInfo *GenerateInitInstance(const HistogramManager*)
   {
      HistogramManager *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("HistogramManager", HistogramManager::Class_Version(), "Event.h", 258,
                  typeid(HistogramManager), DefineBehavior(ptr, ptr),
                  &::HistogramManager::Dictionary, &HistogramManager_IsA, 0,
                  sizeof(HistogramManager) );
      instance.SetDelete(&delete_HistogramManager);
      instance.SetDeleteArray(&deleteArray_HistogramManager);
      instance.SetDestructor(&destruct_HistogramManager);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const HistogramManager*)0x0); R__UseDummy(_R__UNIQUE_(Init));
}

//______________________________________________________________________________
TClass *UShortVector::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *UShortVector::Class_Name()
{
   return "UShortVector";
}

//______________________________________________________________________________
const char *UShortVector::ImplFileName()
{
   return ROOT::GenerateInitInstance((const UShortVector*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int UShortVector::ImplFileLine()
{
   return ROOT::GenerateInitInstance((const UShortVector*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void UShortVector::Dictionary()
{
   fgIsA = ROOT::GenerateInitInstance((const UShortVector*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *UShortVector::Class()
{
   if (!fgIsA) fgIsA = ROOT::GenerateInitInstance((const UShortVector*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *EventHeader::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *EventHeader::Class_Name()
{
   return "EventHeader";
}

//______________________________________________________________________________
const char *EventHeader::ImplFileName()
{
   return ROOT::GenerateInitInstance((const EventHeader*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int EventHeader::ImplFileLine()
{
   return ROOT::GenerateInitInstance((const EventHeader*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void EventHeader::Dictionary()
{
   fgIsA = ROOT::GenerateInitInstance((const EventHeader*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *EventHeader::Class()
{
   if (!fgIsA) fgIsA = ROOT::GenerateInitInstance((const EventHeader*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *Event::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *Event::Class_Name()
{
   return "Event";
}

//______________________________________________________________________________
const char *Event::ImplFileName()
{
   return ROOT::GenerateInitInstance((const Event*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Event::ImplFileLine()
{
   return ROOT::GenerateInitInstance((const Event*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Event::Dictionary()
{
   fgIsA = ROOT::GenerateInitInstance((const Event*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Event::Class()
{
   if (!fgIsA) fgIsA = ROOT::GenerateInitInstance((const Event*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *Track::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *Track::Class_Name()
{
   return "Track";
}

//______________________________________________________________________________
const char *Track::ImplFileName()
{
   return ROOT::GenerateInitInstance((const Track*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int Track::ImplFileLine()
{
   return ROOT::GenerateInitInstance((const Track*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void Track::Dictionary()
{
   fgIsA = ROOT::GenerateInitInstance((const Track*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *Track::Class()
{
   if (!fgIsA) fgIsA = ROOT::GenerateInitInstance((const Track*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *BigTrack::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *BigTrack::Class_Name()
{
   return "BigTrack";
}

//______________________________________________________________________________
const char *BigTrack::ImplFileName()
{
   return ROOT::GenerateInitInstance((const BigTrack*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int BigTrack::ImplFileLine()
{
   return ROOT::GenerateInitInstance((const BigTrack*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void BigTrack::Dictionary()
{
   fgIsA = ROOT::GenerateInitInstance((const BigTrack*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *BigTrack::Class()
{
   if (!fgIsA) fgIsA = ROOT::GenerateInitInstance((const BigTrack*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
TClass *HistogramManager::fgIsA = 0;  // static to hold class pointer

//______________________________________________________________________________
const char *HistogramManager::Class_Name()
{
   return "HistogramManager";
}

//______________________________________________________________________________
const char *HistogramManager::ImplFileName()
{
   return ROOT::GenerateInitInstance((const HistogramManager*)0x0)->GetImplFileName();
}

//______________________________________________________________________________
int HistogramManager::ImplFileLine()
{
   return ROOT::GenerateInitInstance((const HistogramManager*)0x0)->GetImplFileLine();
}

//______________________________________________________________________________
void HistogramManager::Dictionary()
{
   fgIsA = ROOT::GenerateInitInstance((const HistogramManager*)0x0)->GetClass();
}

//______________________________________________________________________________
TClass *HistogramManager::Class()
{
   if (!fgIsA) fgIsA = ROOT::GenerateInitInstance((const HistogramManager*)0x0)->GetClass();
   return fgIsA;
}

//______________________________________________________________________________
void EventHeader::Streamer(TBuffer &R__b)
{
   // Stream an object of class EventHeader.

   if (R__b.IsReading()) {
      EventHeader::Class()->ReadBuffer(R__b, this);
   } else {
      EventHeader::Class()->WriteBuffer(R__b, this);
   }
}

//______________________________________________________________________________
void EventHeader::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class EventHeader.

      TClass *R__cl = EventHeader::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fEvtNum", &fEvtNum);
      R__insp.Inspect(R__cl, R__parent, "fRun", &fRun);
      R__insp.Inspect(R__cl, R__parent, "fDate", &fDate);
}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *EventHeader_IsA(const void *obj) {
      return ((::EventHeader*)obj)->IsA();
   }
   // Wrappers around operator new
   static void *new_EventHeader(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) ::EventHeader : new ::EventHeader;
   }
   static void *newArray_EventHeader(Long_t size) {
      return new ::EventHeader[size];
   }
   // Wrapper around operator delete
   static void delete_EventHeader(void *p) {
      delete ((::EventHeader*)p);
   }
   static void deleteArray_EventHeader(void *p) {
      delete [] ((::EventHeader*)p);
   }
   static void destruct_EventHeader(void *p) {
      typedef ::EventHeader current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::EventHeader

//______________________________________________________________________________
void R__Event_fTstringp(TBuffer &R__b, void *R__p, int R__n)
{
   TString** fTstringp = (TString**)R__p;
   if (R__b.IsReading()) {
      delete [] *fTstringp;
      if (!R__n) return;
      *fTstringp = new TString[R__n];
      TString* R__s = *fTstringp;
      for (Int_t R__l = 0; R__l < R__n; R__l++) {
         R__s[R__l].Streamer(R__b);
      }
   } else {
      TString* R__s = *fTstringp;
      for (Int_t R__l = 0; R__l < R__n; R__l++) {
         R__s[R__l].Streamer(R__b);
      }
   }
}

//______________________________________________________________________________
void R__Event_fPaxis(TBuffer &R__b, void *R__p, int R__n)
{
   TAxis** fPaxis = (TAxis**)R__p;
   if (R__b.IsReading()) {
      delete [] *fPaxis;
      if (!R__n) return;
      *fPaxis = new TAxis[R__n];
      TAxis* R__s = *fPaxis;
      for (Int_t R__l = 0; R__l < R__n; R__l++) {
         R__s[R__l].Streamer(R__b);
      }
   } else {
      TAxis* R__s = *fPaxis;
      for (Int_t R__l = 0; R__l < R__n; R__l++) {
         R__s[R__l].Streamer(R__b);
      }
   }
}

//______________________________________________________________________________
void R__Event_fQaxis(TBuffer &R__b, void *R__p, int R__n)
{
   TAxis*** fQaxis = (TAxis***)R__p;
   if (R__b.IsReading()) {
      delete [] *fQaxis;
      if (!R__n) return;
      *fQaxis = new TAxis*[R__n];
      TAxis** R__s = *fQaxis;
      for (Int_t R__l = 0; R__l < R__n; R__l++) {
         R__s[R__l] = new TAxis();
         R__s[R__l]->Streamer(R__b);
      }
   } else {
      TAxis** R__s = *fQaxis;
      for (Int_t R__l = 0; R__l < R__n; R__l++) {
         R__s[R__l]->Streamer(R__b);
      }
   }
}

//______________________________________________________________________________
void Event::Streamer(TBuffer &R__b)
{
   // Stream an object of class Event.

   if (R__b.IsReading()) {
      Event::Class()->ReadBuffer(R__b, this);
   } else {
      Event::Class()->WriteBuffer(R__b, this);
   }
}

//______________________________________________________________________________
void Event::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class Event.

      TClass *R__cl = Event::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fType[20]", fType);
      R__insp.Inspect(R__cl, R__parent, "*fEventName", &fEventName);
      R__insp.Inspect(R__cl, R__parent, "fBoolA", &fBoolA);
      R__insp.Inspect(R__cl, R__parent, "fNtrack", &fNtrack);
      R__insp.Inspect(R__cl, R__parent, "fNseg", &fNseg);
      R__insp.Inspect(R__cl, R__parent, "fNvertex", &fNvertex);
      R__insp.Inspect(R__cl, R__parent, "fMeasures[10]", fMeasures);
      R__insp.Inspect(R__cl, R__parent, "fFlag", &fFlag);
      R__insp.Inspect(R__cl, R__parent, "fMatrix[4][4]", fMatrix);
      R__insp.Inspect(R__cl, R__parent, "*fClosestDistance", &fClosestDistance);
      R__insp.Inspect(R__cl, R__parent, "fTemperature", &fTemperature);
      R__insp.Inspect(R__cl, R__parent, "*fTracksInVertex", &fTracksInVertex);
      R__insp.Inspect(R__cl, R__parent, "fVectorLong64", (void*)&fVectorLong64);
      ROOT::GenericShowMembers("vector<Long64_t>", (void*)&fVectorLong64, R__insp, strcat(R__parent,"fVectorLong64."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVectorint2", (void*)&fVectorint2);
      ROOT::GenericShowMembers("vector<Int_t>", (void*)&fVectorint2, R__insp, strcat(R__parent,"fVectorint2."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVectorint", (void*)&fVectorint);
      ROOT::GenericShowMembers("vector<int>", (void*)&fVectorint, R__insp, strcat(R__parent,"fVectorint."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVectorshort", (void*)&fVectorshort);
      ROOT::GenericShowMembers("vector<short>", (void*)&fVectorshort, R__insp, strcat(R__parent,"fVectorshort."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVectorD[4]", fVectorD);
      R__insp.Inspect(R__cl, R__parent, "fVectorTLine", (void*)&fVectorTLine);
      ROOT::GenericShowMembers("vector<TLine>", (void*)&fVectorTLine, R__insp, strcat(R__parent,"fVectorTLine."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fVectorTobject", &fVectorTobject);
      R__insp.Inspect(R__cl, R__parent, "*fVectorTnamed[6]", &fVectorTnamed);
      R__insp.Inspect(R__cl, R__parent, "fLachaud", (void*)&fLachaud);
      ROOT::GenericShowMembers("vector<string>", (void*)&fLachaud, R__insp, strcat(R__parent,"fLachaud."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fDeque", (void*)&fDeque);
      ROOT::GenericShowMembers("deque<TAttLine>", (void*)&fDeque, R__insp, strcat(R__parent,"fDeque."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVectorTobjectp", (void*)&fVectorTobjectp);
      ROOT::GenericShowMembers("list<const TObject*>", (void*)&fVectorTobjectp, R__insp, strcat(R__parent,"fVectorTobjectp."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fListString", &fListString);
      R__insp.Inspect(R__cl, R__parent, "fListStringp", (void*)&fListStringp);
      ROOT::GenericShowMembers("list<string*>", (void*)&fListStringp, R__insp, strcat(R__parent,"fListStringp."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapTNamedp", (void*)&fMapTNamedp);
      ROOT::GenericShowMembers("map<TNamed*,int>", (void*)&fMapTNamedp, R__insp, strcat(R__parent,"fMapTNamedp."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fTemplateMember", (void*)&fTemplateMember);
      ROOT::GenericShowMembers("template2<template1<int> >", (void*)&fTemplateMember, R__insp, strcat(R__parent,"fTemplateMember."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapList", (void*)&fMapList);
      ROOT::GenericShowMembers("map<TString,TList*>", (void*)&fMapList, R__insp, strcat(R__parent,"fMapList."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapTString", (void*)&fMapTString);
      ROOT::GenericShowMembers("map<TString,TString*>", (void*)&fMapTString, R__insp, strcat(R__parent,"fMapTString."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapHeaderP", (void*)&fMapHeaderP);
      ROOT::GenericShowMembers("map<EventHeader,TString*>", (void*)&fMapHeaderP, R__insp, strcat(R__parent,"fMapHeaderP."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapHeader", (void*)&fMapHeader);
      ROOT::GenericShowMembers("map<EventHeader,TString>", (void*)&fMapHeader, R__insp, strcat(R__parent,"fMapHeader."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapHeaderst", (void*)&fMapHeaderst);
      ROOT::GenericShowMembers("map<EventHeader,string>", (void*)&fMapHeaderst, R__insp, strcat(R__parent,"fMapHeaderst."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fMapTAxisp", &fMapTAxisp);
      R__insp.Inspect(R__cl, R__parent, "fSetTAxis", (void*)&fSetTAxis);
      ROOT::GenericShowMembers("set<TAxis*>", (void*)&fSetTAxis, R__insp, strcat(R__parent,"fSetTAxis."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fSetTAxisp", &fSetTAxisp);
      R__insp.Inspect(R__cl, R__parent, "fMultiMapTNamedp", (void*)&fMultiMapTNamedp);
      ROOT::GenericShowMembers("multimap<TNamed*,int>", (void*)&fMultiMapTNamedp, R__insp, strcat(R__parent,"fMultiMapTNamedp."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fMultiSetTAxisp", &fMultiSetTAxisp);
      R__insp.Inspect(R__cl, R__parent, "fVectAxis", (void*)&fVectAxis);
      ROOT::GenericShowMembers("vector<vector<TAxis*> >", (void*)&fVectAxis, R__insp, strcat(R__parent,"fVectAxis."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMapString", (void*)&fMapString);
      ROOT::GenericShowMembers("map<string,vector<int> >", (void*)&fMapString, R__insp, strcat(R__parent,"fMapString."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fDequePair", (void*)&fDequePair);
      ROOT::GenericShowMembers("deque<pair<float,float> >", (void*)&fDequePair, R__insp, strcat(R__parent,"fDequePair."),true);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fString", &fString);
      R__insp.Inspect(R__cl, R__parent, "*fStringp", &fStringp);
      R__insp.Inspect(R__cl, R__parent, "*fTstringp", &fTstringp);
      R__cl->SetMemberStreamer("*fTstringp",R__Event_fTstringp);
      R__insp.Inspect(R__cl, R__parent, "fNames[12]", fNames);
      R__insp.Inspect(R__cl, R__parent, "fXaxis", &fXaxis);
      fXaxis.ShowMembers(R__insp, strcat(R__parent,"fXaxis.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fYaxis[3]", fYaxis);
      R__insp.Inspect(R__cl, R__parent, "*fVaxis[3]", &fVaxis);
      R__insp.Inspect(R__cl, R__parent, "*fPaxis", &fPaxis);
      R__cl->SetMemberStreamer("*fPaxis",R__Event_fPaxis);
      R__insp.Inspect(R__cl, R__parent, "*fQaxis", &fQaxis);
      R__cl->SetMemberStreamer("*fQaxis",R__Event_fQaxis);
      R__insp.Inspect(R__cl, R__parent, "fDatime", &fDatime);
      fDatime.ShowMembers(R__insp, strcat(R__parent,"fDatime.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fEvtHdr", &fEvtHdr);
      fEvtHdr.ShowMembers(R__insp, strcat(R__parent,"fEvtHdr.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fObjArray", &fObjArray);
      fObjArray.ShowMembers(R__insp, strcat(R__parent,"fObjArray.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fTracks", &fTracks);
      R__insp.Inspect(R__cl, R__parent, "*fH", &fH);
      R__insp.Inspect(R__cl, R__parent, "fLorentz", &fLorentz);
      fLorentz.ShowMembers(R__insp, strcat(R__parent,"fLorentz.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fArrayF", &fArrayF);
      fArrayF.ShowMembers(R__insp, strcat(R__parent,"fArrayF.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "*fArrayI", &fArrayI);
      R__insp.Inspect(R__cl, R__parent, "fUshort", &fUshort);
      fUshort.ShowMembers(R__insp, strcat(R__parent,"fUshort.")); R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fRefH", &fRefH);
      fRefH.ShowMembers(R__insp, strcat(R__parent,"fRefH.")); R__parent[R__ncp] = 0;
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *Event_IsA(const void *obj) {
      return ((::Event*)obj)->IsA();
   }
   // Wrappers around operator new
   static void *new_Event(void *p) {
      return  p ? new(p) ::Event : new ::Event;
   }
   static void *newArray_Event(Long_t size) {
      return new ::Event[size];
   }
   // Wrapper around operator delete
   static void delete_Event(void *p) {
      delete ((::Event*)p);
   }
   static void deleteArray_Event(void *p) {
      delete [] ((::Event*)p);
   }
   static void destruct_Event(void *p) {
      typedef ::Event current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Event

//______________________________________________________________________________
void HistogramManager::Streamer(TBuffer &R__b)
{
   // Stream an object of class HistogramManager.

   UInt_t R__s, R__c;
   if (R__b.IsReading()) {
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c); if (R__v) { }
      R__b >> fNtrack;
      R__b >> fNseg;
      R__b >> fTemperature;
      R__b >> fPx;
      R__b >> fPy;
      R__b >> fPz;
      R__b >> fRandom;
      R__b >> fMass2;
      R__b >> fBx;
      R__b >> fBy;
      R__b >> fMeanCharge;
      R__b >> fXfirst;
      R__b >> fXlast;
      R__b >> fYfirst;
      R__b >> fYlast;
      R__b >> fZfirst;
      R__b >> fZlast;
      R__b >> fCharge;
      R__b >> fNpoint;
      R__b >> fValid;
      R__b.CheckByteCount(R__s, R__c, HistogramManager::IsA());
   } else {
      R__c = R__b.WriteVersion(HistogramManager::IsA(), kTRUE);
      R__b << (TObject*)fNtrack;
      R__b << (TObject*)fNseg;
      R__b << (TObject*)fTemperature;
      R__b << (TObject*)fPx;
      R__b << (TObject*)fPy;
      R__b << (TObject*)fPz;
      R__b << (TObject*)fRandom;
      R__b << (TObject*)fMass2;
      R__b << (TObject*)fBx;
      R__b << (TObject*)fBy;
      R__b << (TObject*)fMeanCharge;
      R__b << (TObject*)fXfirst;
      R__b << (TObject*)fXlast;
      R__b << (TObject*)fYfirst;
      R__b << (TObject*)fYlast;
      R__b << (TObject*)fZfirst;
      R__b << (TObject*)fZlast;
      R__b << (TObject*)fCharge;
      R__b << (TObject*)fNpoint;
      R__b << (TObject*)fValid;
      R__b.SetByteCount(R__c, kTRUE);
   }
}

//______________________________________________________________________________
void HistogramManager::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class HistogramManager.

      TClass *R__cl = HistogramManager::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "*fNtrack", &fNtrack);
      R__insp.Inspect(R__cl, R__parent, "*fNseg", &fNseg);
      R__insp.Inspect(R__cl, R__parent, "*fTemperature", &fTemperature);
      R__insp.Inspect(R__cl, R__parent, "*fPx", &fPx);
      R__insp.Inspect(R__cl, R__parent, "*fPy", &fPy);
      R__insp.Inspect(R__cl, R__parent, "*fPz", &fPz);
      R__insp.Inspect(R__cl, R__parent, "*fRandom", &fRandom);
      R__insp.Inspect(R__cl, R__parent, "*fMass2", &fMass2);
      R__insp.Inspect(R__cl, R__parent, "*fBx", &fBx);
      R__insp.Inspect(R__cl, R__parent, "*fBy", &fBy);
      R__insp.Inspect(R__cl, R__parent, "*fMeanCharge", &fMeanCharge);
      R__insp.Inspect(R__cl, R__parent, "*fXfirst", &fXfirst);
      R__insp.Inspect(R__cl, R__parent, "*fXlast", &fXlast);
      R__insp.Inspect(R__cl, R__parent, "*fYfirst", &fYfirst);
      R__insp.Inspect(R__cl, R__parent, "*fYlast", &fYlast);
      R__insp.Inspect(R__cl, R__parent, "*fZfirst", &fZfirst);
      R__insp.Inspect(R__cl, R__parent, "*fZlast", &fZlast);
      R__insp.Inspect(R__cl, R__parent, "*fCharge", &fCharge);
      R__insp.Inspect(R__cl, R__parent, "*fNpoint", &fNpoint);
      R__insp.Inspect(R__cl, R__parent, "*fValid", &fValid);
}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *HistogramManager_IsA(const void *obj) {
      return ((::HistogramManager*)obj)->IsA();
   }
   // Wrapper around operator delete
   static void delete_HistogramManager(void *p) {
      delete ((::HistogramManager*)p);
   }
   static void deleteArray_HistogramManager(void *p) {
      delete [] ((::HistogramManager*)p);
   }
   static void destruct_HistogramManager(void *p) {
      typedef ::HistogramManager current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::HistogramManager

//______________________________________________________________________________
void Track::Streamer(TBuffer &R__b)
{
   // Stream an object of class Track.

   if (R__b.IsReading()) {
      Track::Class()->ReadBuffer(R__b, this);
   } else {
      Track::Class()->WriteBuffer(R__b, this);
   }
}

//______________________________________________________________________________
void Track::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class Track.

      TClass *R__cl = Track::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fPx", &fPx);
      R__insp.Inspect(R__cl, R__parent, "fPy", &fPy);
      R__insp.Inspect(R__cl, R__parent, "fPz", &fPz);
      R__insp.Inspect(R__cl, R__parent, "fRandom", &fRandom);
      R__insp.Inspect(R__cl, R__parent, "fMass2", &fMass2);
      R__insp.Inspect(R__cl, R__parent, "fBx", &fBx);
      R__insp.Inspect(R__cl, R__parent, "fBy", &fBy);
      R__insp.Inspect(R__cl, R__parent, "fMeanCharge", &fMeanCharge);
      R__insp.Inspect(R__cl, R__parent, "fXfirst", &fXfirst);
      R__insp.Inspect(R__cl, R__parent, "fXlast", &fXlast);
      R__insp.Inspect(R__cl, R__parent, "fYfirst", &fYfirst);
      R__insp.Inspect(R__cl, R__parent, "fYlast", &fYlast);
      R__insp.Inspect(R__cl, R__parent, "fZfirst", &fZfirst);
      R__insp.Inspect(R__cl, R__parent, "fZlast", &fZlast);
      R__insp.Inspect(R__cl, R__parent, "fHits", (void*)&fHits);
      ROOT::GenericShowMembers("vector<int>", (void*)&fHits, R__insp, strcat(R__parent,"fHits."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fCharge", &fCharge);
      R__insp.Inspect(R__cl, R__parent, "fVertex[3]", fVertex);
      R__insp.Inspect(R__cl, R__parent, "fCovar[3][4]", fCovar);
      R__insp.Inspect(R__cl, R__parent, "fCovara[3][4][2]", fCovara);
      R__insp.Inspect(R__cl, R__parent, "fNpoint", &fNpoint);
      R__insp.Inspect(R__cl, R__parent, "fValid", &fValid);
      R__insp.Inspect(R__cl, R__parent, "*fPoints", &fPoints);
      R__insp.Inspect(R__cl, R__parent, "*fTrackName", &fTrackName);
      R__insp.Inspect(R__cl, R__parent, "fInts", &fInts);
      fInts.ShowMembers(R__insp, strcat(R__parent,"fInts.")); R__parent[R__ncp] = 0;
      TObject::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *Track_IsA(const void *obj) {
      return ((::Track*)obj)->IsA();
   }
   // Wrappers around operator new
   static void *new_Track(void *p) {
      return  p ? new(p) ::Track : new ::Track;
   }
   static void *newArray_Track(Long_t size) {
      return new ::Track[size];
   }
   // Wrapper around operator delete
   static void delete_Track(void *p) {
      delete ((::Track*)p);
   }
   static void deleteArray_Track(void *p) {
      delete [] ((::Track*)p);
   }
   static void destruct_Track(void *p) {
      typedef ::Track current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Track

//______________________________________________________________________________
void BigTrack::Streamer(TBuffer &R__b)
{
   // Stream an object of class BigTrack.

   if (R__b.IsReading()) {
      BigTrack::Class()->ReadBuffer(R__b, this);
   } else {
      BigTrack::Class()->WriteBuffer(R__b, this);
   }
}

//______________________________________________________________________________
void BigTrack::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class BigTrack.

      TClass *R__cl = BigTrack::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fSpecial", &fSpecial);
      R__insp.Inspect(R__cl, R__parent, "fKine", &fKine);
      fKine.ShowMembers(R__insp, strcat(R__parent,"fKine.")); R__parent[R__ncp] = 0;
      Track::ShowMembers(R__insp, R__parent);
}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *BigTrack_IsA(const void *obj) {
      return ((::BigTrack*)obj)->IsA();
   }
   // Wrappers around operator new
   static void *new_BigTrack(void *p) {
      return  p ? new(p) ::BigTrack : new ::BigTrack;
   }
   static void *newArray_BigTrack(Long_t size) {
      return new ::BigTrack[size];
   }
   // Wrapper around operator delete
   static void delete_BigTrack(void *p) {
      delete ((::BigTrack*)p);
   }
   static void deleteArray_BigTrack(void *p) {
      delete [] ((::BigTrack*)p);
   }
   static void destruct_BigTrack(void *p) {
      typedef ::BigTrack current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::BigTrack

//______________________________________________________________________________
void UShortVector::Streamer(TBuffer &R__b)
{
   // Stream an object of class UShortVector.

   if (R__b.IsReading()) {
      UShortVector::Class()->ReadBuffer(R__b, this);
   } else {
      UShortVector::Class()->WriteBuffer(R__b, this);
   }
}

//______________________________________________________________________________
void UShortVector::ShowMembers(TMemberInspector &R__insp, char *R__parent)
{
      // Inspect the data members of an object of class UShortVector.

      TClass *R__cl = UShortVector::IsA();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fNshorts", &fNshorts);
      ROOT::GenericShowMembers("vector<unsigned short,allocator<unsigned short> >", ( ::vector<unsigned short,allocator<unsigned short> > *) (this ), R__insp, R__parent, false);
}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *UShortVector_IsA(const void *obj) {
      return ((::UShortVector*)obj)->IsA();
   }
   // Wrappers around operator new
   static void *new_UShortVector(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) ::UShortVector : new ::UShortVector;
   }
   static void *newArray_UShortVector(Long_t size) {
      return new ::UShortVector[size];
   }
   // Wrapper around operator delete
   static void delete_UShortVector(void *p) {
      delete ((::UShortVector*)p);
   }
   static void deleteArray_UShortVector(void *p) {
      delete [] ((::UShortVector*)p);
   }
   static void destruct_UShortVector(void *p) {
      typedef ::UShortVector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::UShortVector

//______________________________________________________________________________
namespace ROOT {
   void template1lEintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class template1<int>.

      typedef ROOT::Shadow::template1lEintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ROOT::GenerateInitInstance((const template1<int>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *template1lEintgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(::template1<int>*)obj));
   }
   // Wrappers around operator new
   static void *new_template1lEintgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) ::template1<int> : new ::template1<int>;
   }
   static void *newArray_template1lEintgR(Long_t size) {
      return new ::template1<int>[size];
   }
   // Wrapper around operator delete
   static void delete_template1lEintgR(void *p) {
      delete ((::template1<int>*)p);
   }
   static void deleteArray_template1lEintgR(void *p) {
      delete [] ((::template1<int>*)p);
   }
   static void destruct_template1lEintgR(void *p) {
      typedef ::template1<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::template1<int>

//______________________________________________________________________________
namespace ROOT {
   void template2lEtemplate1lEintgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class template2<template1<int> >.

      typedef ROOT::Shadow::template2lEtemplate1lEintgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ROOT::GenerateInitInstance((const template2<template1<int> >*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *template2lEtemplate1lEintgRsPgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(::template2<template1<int> >*)obj));
   }
   // Wrappers around operator new
   static void *new_template2lEtemplate1lEintgRsPgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) ::template2<template1<int> > : new ::template2<template1<int> >;
   }
   static void *newArray_template2lEtemplate1lEintgRsPgR(Long_t size) {
      return new ::template2<template1<int> >[size];
   }
   // Wrapper around operator delete
   static void delete_template2lEtemplate1lEintgRsPgR(void *p) {
      delete ((::template2<template1<int> >*)p);
   }
   static void deleteArray_template2lEtemplate1lEintgRsPgR(void *p) {
      delete [] ((::template2<template1<int> >*)p);
   }
   static void destruct_template2lEtemplate1lEintgRsPgR(void *p) {
      typedef ::template2<template1<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::template2<template1<int> >

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef deque<TAttLine> dequelETAttLinegR;
   static void stl_streamer_dequelETAttLinegR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for deque<TAttLine> at %p",R__p);
      deque<TAttLine> &R__stl = *(deque<TAttLine> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TAttLine R__t;
            R__t.Streamer(R__b);
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            deque<TAttLine>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            ((TAttLine&)(*R__k)).Streamer(R__b);
            }
         }
      }
   } // end of deque<TAttLine,allocator<TAttLine> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(dequelETAttLinegR,stl_streamer_dequelETAttLinegR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef list<const TObject*> listlEconstsPTObjectmUgR;
   static void stl_streamer_listlEconstsPTObjectmUgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for list<const TObject*> at %p",R__p);
      list<const TObject*> &R__stl = *(list<const TObject*> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(TObject));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            const TObject* R__t;
            R__t = (const TObject*)R__b.ReadObjectAny(R__tcl1);
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl1 = TBuffer::GetClass(typeid(TObject));
            if (R__tcl1==0) {
               Error("list<const TObject*> streamer","Missing the TClass object for TObject!");
               return;
            }
            list<const TObject*>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of list<const TObject*,allocator<const TObject*> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(listlEconstsPTObjectmUgR,stl_streamer_listlEconstsPTObjectmUgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef list<string*> listlEstringmUgR;
   static void stl_streamer_listlEstringmUgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for list<string*> at %p",R__p);
      list<string*> &R__stl = *(list<string*> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            string* R__t;
            {TString R__str;
             R__str.Streamer(R__b);
             R__t = new string(R__str.Data());}
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            list<string*>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            {TString R__str((*R__k)->c_str());
             R__str.Streamer(R__b);}
            }
         }
      }
   } // end of list<string*,allocator<string*> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(listlEstringmUgR,stl_streamer_listlEstringmUgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef list<string> listlEstringgR;
   static void stl_streamer_listlEstringgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for list<string> at %p",R__p);
      list<string> &R__stl = *(list<string> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            string R__t;
            {TString R__str;
             R__str.Streamer(R__b);
             R__t = R__str.Data();}
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            list<string>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            {TString R__str((*R__k).c_str());
             R__str.Streamer(R__b);};
            }
         }
      }
   } // end of list<string,allocator<string> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(listlEstringgR,stl_streamer_listlEstringgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef map<TAxis*,int> maplETAxismUcOintgR;
   static void stl_streamer_maplETAxismUcOintgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for map<TAxis*,int> at %p",R__p);
      map<TAxis*,int> &R__stl = *(map<TAxis*,int> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(TAxis));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TAxis* R__t;
            R__t = (TAxis*)R__b.ReadObjectAny(R__tcl1);
            int R__t2;
            R__b >> R__t2;
            R__stl.insert(make_pair(R__t,R__t2));
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl1 = TBuffer::GetClass(typeid(TAxis));
            if (R__tcl1==0) {
               Error("map<TAxis*,int> streamer","Missing the TClass object for TAxis!");
               return;
            }
            map<TAxis*,int>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << ((*R__k).first );
            R__b << ((*R__k).second);
            }
         }
      }
   } // end of map<TAxis*,int,less<TAxis*>,allocator<pair<const TAxis*,int> > > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(maplETAxismUcOintgR,stl_streamer_maplETAxismUcOintgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef map<TNamed*,int> maplETNamedmUcOintgR;
   static void stl_streamer_maplETNamedmUcOintgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for map<TNamed*,int> at %p",R__p);
      map<TNamed*,int> &R__stl = *(map<TNamed*,int> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(TNamed));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TNamed* R__t;
            R__t = (TNamed*)R__b.ReadObjectAny(R__tcl1);
            int R__t2;
            R__b >> R__t2;
            R__stl.insert(make_pair(R__t,R__t2));
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl1 = TBuffer::GetClass(typeid(TNamed));
            if (R__tcl1==0) {
               Error("map<TNamed*,int> streamer","Missing the TClass object for TNamed!");
               return;
            }
            map<TNamed*,int>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << ((*R__k).first );
            R__b << ((*R__k).second);
            }
         }
      }
   } // end of map<TNamed*,int,less<TNamed*>,allocator<pair<const TNamed*,int> > > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(maplETNamedmUcOintgR,stl_streamer_maplETNamedmUcOintgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef map<TString,TList*> maplETStringcOTListmUgR;
   static void stl_streamer_maplETStringcOTListmUgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for map<TString,TList*> at %p",R__p);
      map<TString,TList*> &R__stl = *(map<TString,TList*> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl2 = TBuffer::GetClass(typeid(TList));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TString R__t;
            R__t.Streamer(R__b);
            TList* R__t2;
            R__t2 = (TList*)R__b.ReadObjectAny(R__tcl2);
            R__stl.insert(make_pair(R__t,R__t2));
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl2 = TBuffer::GetClass(typeid(TList));
            if (R__tcl2==0) {
               Error("map<TString,TList*> streamer","Missing the TClass object for TList!");
               return;
            }
            map<TString,TList*>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            ((TString&)((*R__k).first )).Streamer(R__b);
            R__b << ((*R__k).second);
            }
         }
      }
   } // end of map<TString,TList*,less<TString>,allocator<pair<const TString,TList*> > > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(maplETStringcOTListmUgR,stl_streamer_maplETStringcOTListmUgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef multimap<TNamed*,int> multimaplETNamedmUcOintgR;
   static void stl_streamer_multimaplETNamedmUcOintgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for multimap<TNamed*,int> at %p",R__p);
      multimap<TNamed*,int> &R__stl = *(multimap<TNamed*,int> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(TNamed));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TNamed* R__t;
            R__t = (TNamed*)R__b.ReadObjectAny(R__tcl1);
            int R__t2;
            R__b >> R__t2;
            R__stl.insert(make_pair(R__t,R__t2));
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl1 = TBuffer::GetClass(typeid(TNamed));
            if (R__tcl1==0) {
               Error("multimap<TNamed*,int> streamer","Missing the TClass object for TNamed!");
               return;
            }
            multimap<TNamed*,int>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << ((*R__k).first );
            R__b << ((*R__k).second);
            }
         }
      }
   } // end of multimap<TNamed*,int,less<TNamed*>,allocator<pair<const TNamed*,int> > > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(multimaplETNamedmUcOintgR,stl_streamer_multimaplETNamedmUcOintgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef multiset<TAxis*> multisetlETAxismUgR;
   static void stl_streamer_multisetlETAxismUgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for multiset<TAxis*> at %p",R__p);
      multiset<TAxis*> &R__stl = *(multiset<TAxis*> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(TAxis));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TAxis* R__t;
            R__t = (TAxis*)R__b.ReadObjectAny(R__tcl1);
            R__stl.insert(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl1 = TBuffer::GetClass(typeid(TAxis));
            if (R__tcl1==0) {
               Error("multiset<TAxis*> streamer","Missing the TClass object for TAxis!");
               return;
            }
            multiset<TAxis*>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of multiset<TAxis*,less<TAxis*>,allocator<TAxis*> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(multisetlETAxismUgR,stl_streamer_multisetlETAxismUgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef set<TAxis*> setlETAxismUgR;
   static void stl_streamer_setlETAxismUgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for set<TAxis*> at %p",R__p);
      set<TAxis*> &R__stl = *(set<TAxis*> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         TClass *R__tcl1 = TBuffer::GetClass(typeid(TAxis));
         int R__i, R__n;
         R__b >> R__n;
         for (R__i = 0; R__i < R__n; R__i++) {
            TAxis* R__t;
            R__t = (TAxis*)R__b.ReadObjectAny(R__tcl1);
            R__stl.insert(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            TClass *R__tcl1 = TBuffer::GetClass(typeid(TAxis));
            if (R__tcl1==0) {
               Error("set<TAxis*> streamer","Missing the TClass object for TAxis!");
               return;
            }
            set<TAxis*>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of set<TAxis*,less<TAxis*>,allocator<TAxis*> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(setlETAxismUgR,stl_streamer_setlETAxismUgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<TLine> vectorlETLinegR;
   static void stl_streamer_vectorlETLinegR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<TLine> at %p",R__p);
      vector<TLine> &R__stl = *(vector<TLine> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            TLine R__t;
            R__t.Streamer(R__b);
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<TLine>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            ((TLine&)(*R__k)).Streamer(R__b);
            }
         }
      }
   } // end of vector<TLine,allocator<TLine> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlETLinegR,stl_streamer_vectorlETLinegR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<TNamed> vectorlETNamedgR;
   static void stl_streamer_vectorlETNamedgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<TNamed> at %p",R__p);
      vector<TNamed> &R__stl = *(vector<TNamed> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            TNamed R__t;
            R__t.Streamer(R__b);
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<TNamed>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            ((TNamed&)(*R__k)).Streamer(R__b);
            }
         }
      }
   } // end of vector<TNamed,allocator<TNamed> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlETNamedgR,stl_streamer_vectorlETNamedgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<TObject> vectorlETObjectgR;
   static void stl_streamer_vectorlETObjectgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<TObject> at %p",R__p);
      vector<TObject> &R__stl = *(vector<TObject> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            TObject R__t;
            R__t.Streamer(R__b);
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<TObject>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            ((TObject&)(*R__k)).Streamer(R__b);
            }
         }
      }
   } // end of vector<TObject,allocator<TObject> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlETObjectgR,stl_streamer_vectorlETObjectgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<double> vectorlEdoublegR;
   static void stl_streamer_vectorlEdoublegR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<double> at %p",R__p);
      vector<double> &R__stl = *(vector<double> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            double R__t;
            R__b >> R__t;
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<double>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of vector<double,allocator<double> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlEdoublegR,stl_streamer_vectorlEdoublegR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<int> vectorlEintgR;
   static void stl_streamer_vectorlEintgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<int> at %p",R__p);
      vector<int> &R__stl = *(vector<int> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            int R__t;
            R__b >> R__t;
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<int>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of vector<int,allocator<int> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlEintgR,stl_streamer_vectorlEintgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<Long64_t> vectorlELong64_tgR;
   static void stl_streamer_vectorlELong64_tgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<Long64_t> at %p",R__p);
      vector<Long64_t> &R__stl = *(vector<Long64_t> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            Long64_t R__t;
            R__b >> R__t;
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<Long64_t>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of vector<long long,allocator<long long> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlELong64_tgR,stl_streamer_vectorlELong64_tgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<short> vectorlEshortgR;
   static void stl_streamer_vectorlEshortgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<short> at %p",R__p);
      vector<short> &R__stl = *(vector<short> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            short R__t;
            R__b >> R__t;
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<short>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of vector<short,allocator<short> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlEshortgR,stl_streamer_vectorlEshortgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<string> vectorlEstringgR;
   static void stl_streamer_vectorlEstringgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<string> at %p",R__p);
      vector<string> &R__stl = *(vector<string> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            string R__t;
            {TString R__str;
             R__str.Streamer(R__b);
             R__t = R__str.Data();}
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<string>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            {TString R__str((*R__k).c_str());
             R__str.Streamer(R__b);};
            }
         }
      }
   } // end of vector<string,allocator<string> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlEstringgR,stl_streamer_vectorlEstringgR);

//________________________________________________________________________________________________________________________
namespace ROOT {
   typedef vector<unsigned short> vectorlEunsignedsPshortgR;
   static void stl_streamer_vectorlEunsignedsPshortgR(TBuffer &R__b, void *R__p)
   {
      if (gDebug>1) Info(__FILE__,"Running compiled streamer for vector<unsigned short> at %p",R__p);
      vector<unsigned short> &R__stl = *(vector<unsigned short> *)R__p;
      if (R__b.IsReading()) {
         R__stl.clear();
         int R__i, R__n;
         R__b >> R__n;
         R__stl.reserve(R__n);
         for (R__i = 0; R__i < R__n; R__i++) {
            unsigned short R__t;
            R__b >> R__t;
            R__stl.push_back(R__t);
         }
      } else {
         int R__n=(&R__stl) ? int(R__stl.size()) : 0;
         R__b << R__n;
         if(R__n) {
            vector<unsigned short>::iterator R__k;
            for (R__k = R__stl.begin(); R__k != R__stl.end(); ++R__k) {
            R__b << (*R__k);
            }
         }
      }
   } // end of vector<unsigned short,allocator<unsigned short> > streamer
} // close namespace ROOT

// Register the streamer (a typedef is used to avoid problem with macro parameters
RootStlStreamer(vectorlEunsignedsPshortgR,stl_streamer_vectorlEunsignedsPshortgR);

namespace ROOT {
   void dequelETAttLinegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void dequelETAttLinegR_Dictionary();
   static TClass *dequelETAttLinegR_IsA(const void*);
   static void *new_dequelETAttLinegR(void *p = 0);
   static void *newArray_dequelETAttLinegR(Long_t size);
   static void delete_dequelETAttLinegR(void *p);
   static void deleteArray_dequelETAttLinegR(void *p);
   static void destruct_dequelETAttLinegR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const deque<TAttLine>*)
   {
      deque<TAttLine> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("deque<TAttLine>", GetROOT()->GetVersionInt() / 100, "prec_stl/deque", 35,
                  typeid(deque<TAttLine>), DefineBehavior(ptr, ptr),
                  0, &dequelETAttLinegR_Dictionary, &dequelETAttLinegR_IsA, 0,
                  sizeof(deque<TAttLine>) );
      instance.SetNew(&new_dequelETAttLinegR);
      instance.SetNewArray(&newArray_dequelETAttLinegR);
      instance.SetDelete(&delete_dequelETAttLinegR);
      instance.SetDeleteArray(&deleteArray_dequelETAttLinegR);
      instance.SetDestructor(&destruct_dequelETAttLinegR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const deque<TAttLine>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void dequelETAttLinegR_Dictionary() {
      ROOT::GenerateInitInstance((const deque<TAttLine>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *dequelETAttLinegR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(deque<TAttLine>*)obj));
   }
   // Wrappers around operator new
   static void *new_dequelETAttLinegR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) deque<TAttLine> : new deque<TAttLine>;
   }
   static void *newArray_dequelETAttLinegR(Long_t size) {
      return new deque<TAttLine>[size];
   }
   // Wrapper around operator delete
   static void delete_dequelETAttLinegR(void *p) {
      delete ((deque<TAttLine>*)p);
   }
   static void deleteArray_dequelETAttLinegR(void *p) {
      delete [] ((deque<TAttLine>*)p);
   }
   static void destruct_dequelETAttLinegR(void *p) {
      typedef deque<TAttLine> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class deque<TAttLine>

namespace ROOT {
   void listlEconstsPTObjectmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void listlEconstsPTObjectmUgR_Dictionary();
   static TClass *listlEconstsPTObjectmUgR_IsA(const void*);
   static void *new_listlEconstsPTObjectmUgR(void *p = 0);
   static void *newArray_listlEconstsPTObjectmUgR(Long_t size);
   static void delete_listlEconstsPTObjectmUgR(void *p);
   static void deleteArray_listlEconstsPTObjectmUgR(void *p);
   static void destruct_listlEconstsPTObjectmUgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const list<const TObject*>*)
   {
      list<const TObject*> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("list<const TObject*>", GetROOT()->GetVersionInt() / 100, "prec_stl/list", 37,
                  typeid(list<const TObject*>), DefineBehavior(ptr, ptr),
                  0, &listlEconstsPTObjectmUgR_Dictionary, &listlEconstsPTObjectmUgR_IsA, 0,
                  sizeof(list<const TObject*>) );
      instance.SetNew(&new_listlEconstsPTObjectmUgR);
      instance.SetNewArray(&newArray_listlEconstsPTObjectmUgR);
      instance.SetDelete(&delete_listlEconstsPTObjectmUgR);
      instance.SetDeleteArray(&deleteArray_listlEconstsPTObjectmUgR);
      instance.SetDestructor(&destruct_listlEconstsPTObjectmUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const list<const TObject*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void listlEconstsPTObjectmUgR_Dictionary() {
      ROOT::GenerateInitInstance((const list<const TObject*>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *listlEconstsPTObjectmUgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(list<const TObject*>*)obj));
   }
   // Wrappers around operator new
   static void *new_listlEconstsPTObjectmUgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) list<const TObject*> : new list<const TObject*>;
   }
   static void *newArray_listlEconstsPTObjectmUgR(Long_t size) {
      return new list<const TObject*>[size];
   }
   // Wrapper around operator delete
   static void delete_listlEconstsPTObjectmUgR(void *p) {
      delete ((list<const TObject*>*)p);
   }
   static void deleteArray_listlEconstsPTObjectmUgR(void *p) {
      delete [] ((list<const TObject*>*)p);
   }
   static void destruct_listlEconstsPTObjectmUgR(void *p) {
      typedef list<const TObject*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<const TObject*>

namespace ROOT {
   void listlEstringmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void listlEstringmUgR_Dictionary();
   static TClass *listlEstringmUgR_IsA(const void*);
   static void *new_listlEstringmUgR(void *p = 0);
   static void *newArray_listlEstringmUgR(Long_t size);
   static void delete_listlEstringmUgR(void *p);
   static void deleteArray_listlEstringmUgR(void *p);
   static void destruct_listlEstringmUgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const list<string*>*)
   {
      list<string*> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("list<string*>", GetROOT()->GetVersionInt() / 100, "prec_stl/list", 37,
                  typeid(list<string*>), DefineBehavior(ptr, ptr),
                  0, &listlEstringmUgR_Dictionary, &listlEstringmUgR_IsA, 0,
                  sizeof(list<string*>) );
      instance.SetNew(&new_listlEstringmUgR);
      instance.SetNewArray(&newArray_listlEstringmUgR);
      instance.SetDelete(&delete_listlEstringmUgR);
      instance.SetDeleteArray(&deleteArray_listlEstringmUgR);
      instance.SetDestructor(&destruct_listlEstringmUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const list<string*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void listlEstringmUgR_Dictionary() {
      ROOT::GenerateInitInstance((const list<string*>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *listlEstringmUgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(list<string*>*)obj));
   }
   // Wrappers around operator new
   static void *new_listlEstringmUgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) list<string*> : new list<string*>;
   }
   static void *newArray_listlEstringmUgR(Long_t size) {
      return new list<string*>[size];
   }
   // Wrapper around operator delete
   static void delete_listlEstringmUgR(void *p) {
      delete ((list<string*>*)p);
   }
   static void deleteArray_listlEstringmUgR(void *p) {
      delete [] ((list<string*>*)p);
   }
   static void destruct_listlEstringmUgR(void *p) {
      typedef list<string*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<string*>

namespace ROOT {
   void listlEstringgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void listlEstringgR_Dictionary();
   static TClass *listlEstringgR_IsA(const void*);
   static void *new_listlEstringgR(void *p = 0);
   static void *newArray_listlEstringgR(Long_t size);
   static void delete_listlEstringgR(void *p);
   static void deleteArray_listlEstringgR(void *p);
   static void destruct_listlEstringgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const list<string>*)
   {
      list<string> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("list<string>", GetROOT()->GetVersionInt() / 100, "list.dll", 0,
                  typeid(list<string>), DefineBehavior(ptr, ptr),
                  0, &listlEstringgR_Dictionary, &listlEstringgR_IsA, 0,
                  sizeof(list<string>) );
      instance.SetNew(&new_listlEstringgR);
      instance.SetNewArray(&newArray_listlEstringgR);
      instance.SetDelete(&delete_listlEstringgR);
      instance.SetDeleteArray(&deleteArray_listlEstringgR);
      instance.SetDestructor(&destruct_listlEstringgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const list<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void listlEstringgR_Dictionary() {
      ROOT::GenerateInitInstance((const list<string>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *listlEstringgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(list<string>*)obj));
   }
   // Wrappers around operator new
   static void *new_listlEstringgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) list<string> : new list<string>;
   }
   static void *newArray_listlEstringgR(Long_t size) {
      return new list<string>[size];
   }
   // Wrapper around operator delete
   static void delete_listlEstringgR(void *p) {
      delete ((list<string>*)p);
   }
   static void deleteArray_listlEstringgR(void *p) {
      delete [] ((list<string>*)p);
   }
   static void destruct_listlEstringgR(void *p) {
      typedef list<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class list<string>

namespace ROOT {
   void maplETAxismUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void maplETAxismUcOintgR_Dictionary();
   static TClass *maplETAxismUcOintgR_IsA(const void*);
   static void *new_maplETAxismUcOintgR(void *p = 0);
   static void *newArray_maplETAxismUcOintgR(Long_t size);
   static void delete_maplETAxismUcOintgR(void *p);
   static void deleteArray_maplETAxismUcOintgR(void *p);
   static void destruct_maplETAxismUcOintgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const map<TAxis*,int>*)
   {
      map<TAxis*,int> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("map<TAxis*,int>", GetROOT()->GetVersionInt() / 100, "prec_stl/map", 56,
                  typeid(map<TAxis*,int>), DefineBehavior(ptr, ptr),
                  0, &maplETAxismUcOintgR_Dictionary, &maplETAxismUcOintgR_IsA, 0,
                  sizeof(map<TAxis*,int>) );
      instance.SetNew(&new_maplETAxismUcOintgR);
      instance.SetNewArray(&newArray_maplETAxismUcOintgR);
      instance.SetDelete(&delete_maplETAxismUcOintgR);
      instance.SetDeleteArray(&deleteArray_maplETAxismUcOintgR);
      instance.SetDestructor(&destruct_maplETAxismUcOintgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const map<TAxis*,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplETAxismUcOintgR_Dictionary() {
      ROOT::GenerateInitInstance((const map<TAxis*,int>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *maplETAxismUcOintgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(map<TAxis*,int>*)obj));
   }
   // Wrappers around operator new
   static void *new_maplETAxismUcOintgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) map<TAxis*,int> : new map<TAxis*,int>;
   }
   static void *newArray_maplETAxismUcOintgR(Long_t size) {
      return new map<TAxis*,int>[size];
   }
   // Wrapper around operator delete
   static void delete_maplETAxismUcOintgR(void *p) {
      delete ((map<TAxis*,int>*)p);
   }
   static void deleteArray_maplETAxismUcOintgR(void *p) {
      delete [] ((map<TAxis*,int>*)p);
   }
   static void destruct_maplETAxismUcOintgR(void *p) {
      typedef map<TAxis*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TAxis*,int>

namespace ROOT {
   void maplETNamedmUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void maplETNamedmUcOintgR_Dictionary();
   static TClass *maplETNamedmUcOintgR_IsA(const void*);
   static void *new_maplETNamedmUcOintgR(void *p = 0);
   static void *newArray_maplETNamedmUcOintgR(Long_t size);
   static void delete_maplETNamedmUcOintgR(void *p);
   static void deleteArray_maplETNamedmUcOintgR(void *p);
   static void destruct_maplETNamedmUcOintgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const map<TNamed*,int>*)
   {
      map<TNamed*,int> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("map<TNamed*,int>", GetROOT()->GetVersionInt() / 100, "prec_stl/map", 56,
                  typeid(map<TNamed*,int>), DefineBehavior(ptr, ptr),
                  0, &maplETNamedmUcOintgR_Dictionary, &maplETNamedmUcOintgR_IsA, 0,
                  sizeof(map<TNamed*,int>) );
      instance.SetNew(&new_maplETNamedmUcOintgR);
      instance.SetNewArray(&newArray_maplETNamedmUcOintgR);
      instance.SetDelete(&delete_maplETNamedmUcOintgR);
      instance.SetDeleteArray(&deleteArray_maplETNamedmUcOintgR);
      instance.SetDestructor(&destruct_maplETNamedmUcOintgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const map<TNamed*,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplETNamedmUcOintgR_Dictionary() {
      ROOT::GenerateInitInstance((const map<TNamed*,int>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *maplETNamedmUcOintgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(map<TNamed*,int>*)obj));
   }
   // Wrappers around operator new
   static void *new_maplETNamedmUcOintgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) map<TNamed*,int> : new map<TNamed*,int>;
   }
   static void *newArray_maplETNamedmUcOintgR(Long_t size) {
      return new map<TNamed*,int>[size];
   }
   // Wrapper around operator delete
   static void delete_maplETNamedmUcOintgR(void *p) {
      delete ((map<TNamed*,int>*)p);
   }
   static void deleteArray_maplETNamedmUcOintgR(void *p) {
      delete [] ((map<TNamed*,int>*)p);
   }
   static void destruct_maplETNamedmUcOintgR(void *p) {
      typedef map<TNamed*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TNamed*,int>

namespace ROOT {
   void maplETStringcOTListmUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void maplETStringcOTListmUgR_Dictionary();
   static TClass *maplETStringcOTListmUgR_IsA(const void*);
   static void *new_maplETStringcOTListmUgR(void *p = 0);
   static void *newArray_maplETStringcOTListmUgR(Long_t size);
   static void delete_maplETStringcOTListmUgR(void *p);
   static void deleteArray_maplETStringcOTListmUgR(void *p);
   static void destruct_maplETStringcOTListmUgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const map<TString,TList*>*)
   {
      map<TString,TList*> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("map<TString,TList*>", GetROOT()->GetVersionInt() / 100, "prec_stl/map", 56,
                  typeid(map<TString,TList*>), DefineBehavior(ptr, ptr),
                  0, &maplETStringcOTListmUgR_Dictionary, &maplETStringcOTListmUgR_IsA, 0,
                  sizeof(map<TString,TList*>) );
      instance.SetNew(&new_maplETStringcOTListmUgR);
      instance.SetNewArray(&newArray_maplETStringcOTListmUgR);
      instance.SetDelete(&delete_maplETStringcOTListmUgR);
      instance.SetDeleteArray(&deleteArray_maplETStringcOTListmUgR);
      instance.SetDestructor(&destruct_maplETStringcOTListmUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const map<TString,TList*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplETStringcOTListmUgR_Dictionary() {
      ROOT::GenerateInitInstance((const map<TString,TList*>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *maplETStringcOTListmUgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(map<TString,TList*>*)obj));
   }
   // Wrappers around operator new
   static void *new_maplETStringcOTListmUgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) map<TString,TList*> : new map<TString,TList*>;
   }
   static void *newArray_maplETStringcOTListmUgR(Long_t size) {
      return new map<TString,TList*>[size];
   }
   // Wrapper around operator delete
   static void delete_maplETStringcOTListmUgR(void *p) {
      delete ((map<TString,TList*>*)p);
   }
   static void deleteArray_maplETStringcOTListmUgR(void *p) {
      delete [] ((map<TString,TList*>*)p);
   }
   static void destruct_maplETStringcOTListmUgR(void *p) {
      typedef map<TString,TList*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<TString,TList*>

namespace ROOT {
   void multimaplETNamedmUcOintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void multimaplETNamedmUcOintgR_Dictionary();
   static TClass *multimaplETNamedmUcOintgR_IsA(const void*);
   static void *new_multimaplETNamedmUcOintgR(void *p = 0);
   static void *newArray_multimaplETNamedmUcOintgR(Long_t size);
   static void delete_multimaplETNamedmUcOintgR(void *p);
   static void deleteArray_multimaplETNamedmUcOintgR(void *p);
   static void destruct_multimaplETNamedmUcOintgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const multimap<TNamed*,int>*)
   {
      multimap<TNamed*,int> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("multimap<TNamed*,int>", GetROOT()->GetVersionInt() / 100, "prec_stl/multimap", 53,
                  typeid(multimap<TNamed*,int>), DefineBehavior(ptr, ptr),
                  0, &multimaplETNamedmUcOintgR_Dictionary, &multimaplETNamedmUcOintgR_IsA, 0,
                  sizeof(multimap<TNamed*,int>) );
      instance.SetNew(&new_multimaplETNamedmUcOintgR);
      instance.SetNewArray(&newArray_multimaplETNamedmUcOintgR);
      instance.SetDelete(&delete_multimaplETNamedmUcOintgR);
      instance.SetDeleteArray(&deleteArray_multimaplETNamedmUcOintgR);
      instance.SetDestructor(&destruct_multimaplETNamedmUcOintgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const multimap<TNamed*,int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void multimaplETNamedmUcOintgR_Dictionary() {
      ROOT::GenerateInitInstance((const multimap<TNamed*,int>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *multimaplETNamedmUcOintgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(multimap<TNamed*,int>*)obj));
   }
   // Wrappers around operator new
   static void *new_multimaplETNamedmUcOintgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) multimap<TNamed*,int> : new multimap<TNamed*,int>;
   }
   static void *newArray_multimaplETNamedmUcOintgR(Long_t size) {
      return new multimap<TNamed*,int>[size];
   }
   // Wrapper around operator delete
   static void delete_multimaplETNamedmUcOintgR(void *p) {
      delete ((multimap<TNamed*,int>*)p);
   }
   static void deleteArray_multimaplETNamedmUcOintgR(void *p) {
      delete [] ((multimap<TNamed*,int>*)p);
   }
   static void destruct_multimaplETNamedmUcOintgR(void *p) {
      typedef multimap<TNamed*,int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class multimap<TNamed*,int>

namespace ROOT {
   void multisetlETAxismUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void multisetlETAxismUgR_Dictionary();
   static TClass *multisetlETAxismUgR_IsA(const void*);
   static void *new_multisetlETAxismUgR(void *p = 0);
   static void *newArray_multisetlETAxismUgR(Long_t size);
   static void delete_multisetlETAxismUgR(void *p);
   static void deleteArray_multisetlETAxismUgR(void *p);
   static void destruct_multisetlETAxismUgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const multiset<TAxis*>*)
   {
      multiset<TAxis*> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("multiset<TAxis*>", GetROOT()->GetVersionInt() / 100, "prec_stl/multiset", 42,
                  typeid(multiset<TAxis*>), DefineBehavior(ptr, ptr),
                  0, &multisetlETAxismUgR_Dictionary, &multisetlETAxismUgR_IsA, 0,
                  sizeof(multiset<TAxis*>) );
      instance.SetNew(&new_multisetlETAxismUgR);
      instance.SetNewArray(&newArray_multisetlETAxismUgR);
      instance.SetDelete(&delete_multisetlETAxismUgR);
      instance.SetDeleteArray(&deleteArray_multisetlETAxismUgR);
      instance.SetDestructor(&destruct_multisetlETAxismUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const multiset<TAxis*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void multisetlETAxismUgR_Dictionary() {
      ROOT::GenerateInitInstance((const multiset<TAxis*>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *multisetlETAxismUgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(multiset<TAxis*>*)obj));
   }
   // Wrappers around operator new
   static void *new_multisetlETAxismUgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) multiset<TAxis*> : new multiset<TAxis*>;
   }
   static void *newArray_multisetlETAxismUgR(Long_t size) {
      return new multiset<TAxis*>[size];
   }
   // Wrapper around operator delete
   static void delete_multisetlETAxismUgR(void *p) {
      delete ((multiset<TAxis*>*)p);
   }
   static void deleteArray_multisetlETAxismUgR(void *p) {
      delete [] ((multiset<TAxis*>*)p);
   }
   static void destruct_multisetlETAxismUgR(void *p) {
      typedef multiset<TAxis*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class multiset<TAxis*>

namespace ROOT {
   void setlETAxismUgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void setlETAxismUgR_Dictionary();
   static TClass *setlETAxismUgR_IsA(const void*);
   static void *new_setlETAxismUgR(void *p = 0);
   static void *newArray_setlETAxismUgR(Long_t size);
   static void delete_setlETAxismUgR(void *p);
   static void deleteArray_setlETAxismUgR(void *p);
   static void destruct_setlETAxismUgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const set<TAxis*>*)
   {
      set<TAxis*> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("set<TAxis*>", GetROOT()->GetVersionInt() / 100, "prec_stl/set", 42,
                  typeid(set<TAxis*>), DefineBehavior(ptr, ptr),
                  0, &setlETAxismUgR_Dictionary, &setlETAxismUgR_IsA, 0,
                  sizeof(set<TAxis*>) );
      instance.SetNew(&new_setlETAxismUgR);
      instance.SetNewArray(&newArray_setlETAxismUgR);
      instance.SetDelete(&delete_setlETAxismUgR);
      instance.SetDeleteArray(&deleteArray_setlETAxismUgR);
      instance.SetDestructor(&destruct_setlETAxismUgR);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const set<TAxis*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void setlETAxismUgR_Dictionary() {
      ROOT::GenerateInitInstance((const set<TAxis*>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *setlETAxismUgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(set<TAxis*>*)obj));
   }
   // Wrappers around operator new
   static void *new_setlETAxismUgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) set<TAxis*> : new set<TAxis*>;
   }
   static void *newArray_setlETAxismUgR(Long_t size) {
      return new set<TAxis*>[size];
   }
   // Wrapper around operator delete
   static void delete_setlETAxismUgR(void *p) {
      delete ((set<TAxis*>*)p);
   }
   static void deleteArray_setlETAxismUgR(void *p) {
      delete [] ((set<TAxis*>*)p);
   }
   static void destruct_setlETAxismUgR(void *p) {
      typedef set<TAxis*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class set<TAxis*>

namespace ROOT {
   void vectorlETLinegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlETLinegR_Dictionary();
   static TClass *vectorlETLinegR_IsA(const void*);
   static void *new_vectorlETLinegR(void *p = 0);
   static void *newArray_vectorlETLinegR(Long_t size);
   static void delete_vectorlETLinegR(void *p);
   static void deleteArray_vectorlETLinegR(void *p);
   static void destruct_vectorlETLinegR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<TLine>*)
   {
      vector<TLine> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<TLine>", GetROOT()->GetVersionInt() / 100, "prec_stl/vector", 42,
                  typeid(vector<TLine>), DefineBehavior(ptr, ptr),
                  0, &vectorlETLinegR_Dictionary, &vectorlETLinegR_IsA, 0,
                  sizeof(vector<TLine>) );
      instance.SetNew(&new_vectorlETLinegR);
      instance.SetNewArray(&newArray_vectorlETLinegR);
      instance.SetDelete(&delete_vectorlETLinegR);
      instance.SetDeleteArray(&deleteArray_vectorlETLinegR);
      instance.SetDestructor(&destruct_vectorlETLinegR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<TLine> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<TLine>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETLinegR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<TLine>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlETLinegR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<TLine>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlETLinegR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<TLine> : new vector<TLine>;
   }
   static void *newArray_vectorlETLinegR(Long_t size) {
      return new vector<TLine>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlETLinegR(void *p) {
      delete ((vector<TLine>*)p);
   }
   static void deleteArray_vectorlETLinegR(void *p) {
      delete [] ((vector<TLine>*)p);
   }
   static void destruct_vectorlETLinegR(void *p) {
      typedef vector<TLine> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TLine>

namespace ROOT {
   void vectorlETNamedgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlETNamedgR_Dictionary();
   static TClass *vectorlETNamedgR_IsA(const void*);
   static void *new_vectorlETNamedgR(void *p = 0);
   static void *newArray_vectorlETNamedgR(Long_t size);
   static void delete_vectorlETNamedgR(void *p);
   static void deleteArray_vectorlETNamedgR(void *p);
   static void destruct_vectorlETNamedgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<TNamed>*)
   {
      vector<TNamed> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<TNamed>", GetROOT()->GetVersionInt() / 100, "prec_stl/vector", 42,
                  typeid(vector<TNamed>), DefineBehavior(ptr, ptr),
                  0, &vectorlETNamedgR_Dictionary, &vectorlETNamedgR_IsA, 0,
                  sizeof(vector<TNamed>) );
      instance.SetNew(&new_vectorlETNamedgR);
      instance.SetNewArray(&newArray_vectorlETNamedgR);
      instance.SetDelete(&delete_vectorlETNamedgR);
      instance.SetDeleteArray(&deleteArray_vectorlETNamedgR);
      instance.SetDestructor(&destruct_vectorlETNamedgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<TNamed> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<TNamed>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETNamedgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<TNamed>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlETNamedgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<TNamed>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlETNamedgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<TNamed> : new vector<TNamed>;
   }
   static void *newArray_vectorlETNamedgR(Long_t size) {
      return new vector<TNamed>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlETNamedgR(void *p) {
      delete ((vector<TNamed>*)p);
   }
   static void deleteArray_vectorlETNamedgR(void *p) {
      delete [] ((vector<TNamed>*)p);
   }
   static void destruct_vectorlETNamedgR(void *p) {
      typedef vector<TNamed> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TNamed>

namespace ROOT {
   void vectorlETObjectgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlETObjectgR_Dictionary();
   static TClass *vectorlETObjectgR_IsA(const void*);
   static void *new_vectorlETObjectgR(void *p = 0);
   static void *newArray_vectorlETObjectgR(Long_t size);
   static void delete_vectorlETObjectgR(void *p);
   static void deleteArray_vectorlETObjectgR(void *p);
   static void destruct_vectorlETObjectgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<TObject>*)
   {
      vector<TObject> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<TObject>", GetROOT()->GetVersionInt() / 100, "prec_stl/vector", 42,
                  typeid(vector<TObject>), DefineBehavior(ptr, ptr),
                  0, &vectorlETObjectgR_Dictionary, &vectorlETObjectgR_IsA, 0,
                  sizeof(vector<TObject>) );
      instance.SetNew(&new_vectorlETObjectgR);
      instance.SetNewArray(&newArray_vectorlETObjectgR);
      instance.SetDelete(&delete_vectorlETObjectgR);
      instance.SetDeleteArray(&deleteArray_vectorlETObjectgR);
      instance.SetDestructor(&destruct_vectorlETObjectgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<TObject> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<TObject>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETObjectgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<TObject>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlETObjectgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<TObject>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlETObjectgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<TObject> : new vector<TObject>;
   }
   static void *newArray_vectorlETObjectgR(Long_t size) {
      return new vector<TObject>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlETObjectgR(void *p) {
      delete ((vector<TObject>*)p);
   }
   static void deleteArray_vectorlETObjectgR(void *p) {
      delete [] ((vector<TObject>*)p);
   }
   static void destruct_vectorlETObjectgR(void *p) {
      typedef vector<TObject> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TObject>

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEdoublegR_Dictionary();
   static TClass *vectorlEdoublegR_IsA(const void*);
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<double>", GetROOT()->GetVersionInt() / 100, "vector.dll", 0,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, &vectorlEdoublegR_IsA, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<double> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<double>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlEdoublegR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<double>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t size) {
      return new vector<double>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   void vectorlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEintgR_Dictionary();
   static TClass *vectorlEintgR_IsA(const void*);
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<int>", GetROOT()->GetVersionInt() / 100, "vector.dll", 0,
                  typeid(vector<int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEintgR_Dictionary, &vectorlEintgR_IsA, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<int> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEintgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<int>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlEintgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<int>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t size) {
      return new vector<int>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

namespace ROOT {
   void vectorlELong64_tgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlELong64_tgR_Dictionary();
   static TClass *vectorlELong64_tgR_IsA(const void*);
   static void *new_vectorlELong64_tgR(void *p = 0);
   static void *newArray_vectorlELong64_tgR(Long_t size);
   static void delete_vectorlELong64_tgR(void *p);
   static void deleteArray_vectorlELong64_tgR(void *p);
   static void destruct_vectorlELong64_tgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<Long64_t>*)
   {
      vector<Long64_t> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<Long64_t>", GetROOT()->GetVersionInt() / 100, "prec_stl/vector", 42,
                  typeid(vector<Long64_t>), DefineBehavior(ptr, ptr),
                  0, &vectorlELong64_tgR_Dictionary, &vectorlELong64_tgR_IsA, 0,
                  sizeof(vector<Long64_t>) );
      instance.SetNew(&new_vectorlELong64_tgR);
      instance.SetNewArray(&newArray_vectorlELong64_tgR);
      instance.SetDelete(&delete_vectorlELong64_tgR);
      instance.SetDeleteArray(&deleteArray_vectorlELong64_tgR);
      instance.SetDestructor(&destruct_vectorlELong64_tgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<Long64_t> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<Long64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlELong64_tgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<Long64_t>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlELong64_tgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<Long64_t>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlELong64_tgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<Long64_t> : new vector<Long64_t>;
   }
   static void *newArray_vectorlELong64_tgR(Long_t size) {
      return new vector<Long64_t>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlELong64_tgR(void *p) {
      delete ((vector<Long64_t>*)p);
   }
   static void deleteArray_vectorlELong64_tgR(void *p) {
      delete [] ((vector<Long64_t>*)p);
   }
   static void destruct_vectorlELong64_tgR(void *p) {
      typedef vector<Long64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<Long64_t>

namespace ROOT {
   void vectorlEshortgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEshortgR_Dictionary();
   static TClass *vectorlEshortgR_IsA(const void*);
   static void *new_vectorlEshortgR(void *p = 0);
   static void *newArray_vectorlEshortgR(Long_t size);
   static void delete_vectorlEshortgR(void *p);
   static void deleteArray_vectorlEshortgR(void *p);
   static void destruct_vectorlEshortgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<short>*)
   {
      vector<short> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<short>", GetROOT()->GetVersionInt() / 100, "vector.dll", 0,
                  typeid(vector<short>), DefineBehavior(ptr, ptr),
                  0, &vectorlEshortgR_Dictionary, &vectorlEshortgR_IsA, 0,
                  sizeof(vector<short>) );
      instance.SetNew(&new_vectorlEshortgR);
      instance.SetNewArray(&newArray_vectorlEshortgR);
      instance.SetDelete(&delete_vectorlEshortgR);
      instance.SetDeleteArray(&deleteArray_vectorlEshortgR);
      instance.SetDestructor(&destruct_vectorlEshortgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<short> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEshortgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<short>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlEshortgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<short>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlEshortgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<short> : new vector<short>;
   }
   static void *newArray_vectorlEshortgR(Long_t size) {
      return new vector<short>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlEshortgR(void *p) {
      delete ((vector<short>*)p);
   }
   static void deleteArray_vectorlEshortgR(void *p) {
      delete [] ((vector<short>*)p);
   }
   static void destruct_vectorlEshortgR(void *p) {
      typedef vector<short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<short>

namespace ROOT {
   void vectorlEstringgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEstringgR_Dictionary();
   static TClass *vectorlEstringgR_IsA(const void*);
   static void *new_vectorlEstringgR(void *p = 0);
   static void *newArray_vectorlEstringgR(Long_t size);
   static void delete_vectorlEstringgR(void *p);
   static void deleteArray_vectorlEstringgR(void *p);
   static void destruct_vectorlEstringgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<string>*)
   {
      vector<string> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<string>", GetROOT()->GetVersionInt() / 100, "vector.dll", 0,
                  typeid(vector<string>), DefineBehavior(ptr, ptr),
                  0, &vectorlEstringgR_Dictionary, &vectorlEstringgR_IsA, 0,
                  sizeof(vector<string>) );
      instance.SetNew(&new_vectorlEstringgR);
      instance.SetNewArray(&newArray_vectorlEstringgR);
      instance.SetDelete(&delete_vectorlEstringgR);
      instance.SetDeleteArray(&deleteArray_vectorlEstringgR);
      instance.SetDestructor(&destruct_vectorlEstringgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<string> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<string>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEstringgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<string>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlEstringgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<string>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlEstringgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<string> : new vector<string>;
   }
   static void *newArray_vectorlEstringgR(Long_t size) {
      return new vector<string>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlEstringgR(void *p) {
      delete ((vector<string>*)p);
   }
   static void deleteArray_vectorlEstringgR(void *p) {
      delete [] ((vector<string>*)p);
   }
   static void destruct_vectorlEstringgR(void *p) {
      typedef vector<string> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<string>

namespace ROOT {
   void vectorlEunsignedsPshortgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlEunsignedsPshortgR_Dictionary();
   static TClass *vectorlEunsignedsPshortgR_IsA(const void*);
   static void *new_vectorlEunsignedsPshortgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPshortgR(Long_t size);
   static void delete_vectorlEunsignedsPshortgR(void *p);
   static void deleteArray_vectorlEunsignedsPshortgR(void *p);
   static void destruct_vectorlEunsignedsPshortgR(void *p);

   // Function generating the singleton type initializer
   static // The GenerateInitInstance for STL are not unique and should not be externally accessible
   TGenericClassInfo *GenerateInitInstance(const vector<unsigned short>*)
   {
      vector<unsigned short> *ptr = 0;
      static ROOT::TGenericClassInfo 
         instance("vector<unsigned short>", GetROOT()->GetVersionInt() / 100, "prec_stl/vector", 42,
                  typeid(vector<unsigned short>), DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPshortgR_Dictionary, &vectorlEunsignedsPshortgR_IsA, 0,
                  sizeof(vector<unsigned short>) );
      instance.SetNew(&new_vectorlEunsignedsPshortgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPshortgR);
      instance.SetDelete(&delete_vectorlEunsignedsPshortgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPshortgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPshortgR);
      instance.AdoptCollectionProxy(new ROOT::TVectorProxy<vector<unsigned short> >);
      return &instance;
   }
   // Static variable to force the class initialization
   static ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstance((const vector<unsigned short>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPshortgR_Dictionary() {
      ROOT::GenerateInitInstance((const vector<unsigned short>*)0x0)->GetClass();
   }

}

namespace ROOT {
   // Return the actual TClass for the object argument
   static TClass *vectorlEunsignedsPshortgR_IsA(const void *obj) {
      return GetROOT()->GetClass(typeid(*(vector<unsigned short>*)obj));
   }
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPshortgR(void *p) {
      return  p ? ::new((ROOT::TOperatorNewHelper*)p) vector<unsigned short> : new vector<unsigned short>;
   }
   static void *newArray_vectorlEunsignedsPshortgR(Long_t size) {
      return new vector<unsigned short>[size];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPshortgR(void *p) {
      delete ((vector<unsigned short>*)p);
   }
   static void deleteArray_vectorlEunsignedsPshortgR(void *p) {
      delete [] ((vector<unsigned short>*)p);
   }
   static void destruct_vectorlEunsignedsPshortgR(void *p) {
      typedef vector<unsigned short> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned short>

/********************************************************
* EventDict.cxx
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

extern "C" void G__cpp_reset_tagtableEventDict();

extern "C" void G__set_cpp_environmentEventDict() {
  G__add_compiledheader("TROOT.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("Event.h");
  G__cpp_reset_tagtableEventDict();
}
class G__EventDictdOcxx_tag {};

void* operator new(size_t size,G__EventDictdOcxx_tag* p) {
  if(p && G__PVOID!=G__getgvp()) return((void*)p);
#ifndef G__ROOT
  return(malloc(size));
#else
  return(::operator new(size));
#endif
}

/* dummy, for exception */
#ifdef G__EH_DUMMY_DELETE
void operator delete(void *p,G__EventDictdOcxx_tag* x) {
  if((long)p==G__getgvp() && G__PVOID!=G__getgvp()) return;
#ifndef G__ROOT
  free(p);
#else
  ::operator delete(p);
#endif
}
#endif

static void G__operator_delete(void *p) {
  if((long)p==G__getgvp() && G__PVOID!=G__getgvp()) return;
#ifndef G__ROOT
  free(p);
#else
  ::operator delete(p);
#endif
}

void G__DELDMY_EventDictdOcxx() { G__operator_delete(0); }

extern "C" int G__cpp_dllrevEventDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* UShortVector */
static int G__EventDict_600_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   UShortVector *p=NULL;
   if(G__getaryconstruct()) p=new UShortVector[G__getaryconstruct()];
   else p=::new((G__EventDictdOcxx_tag*)G__getgvp()) UShortVector;
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_UShortVector);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   UShortVector *p=NULL;
      p=::new((G__EventDictdOcxx_tag*)G__getgvp()) UShortVector((Int_t)G__int(libp->para[0]));
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_UShortVector);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)UShortVector::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)UShortVector::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_5_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)UShortVector::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_6_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      UShortVector::Dictionary();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_7_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const UShortVector*)(G__getstructoffset()))->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_8_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((UShortVector*)(G__getstructoffset()))->ShowMembers(*(TMemberInspector*)libp->para[0].ref,(char*)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_9_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((UShortVector*)(G__getstructoffset()))->Streamer(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_0_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((UShortVector*)(G__getstructoffset()))->StreamerNVirtual(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_1_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)UShortVector::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_2_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)UShortVector::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_3_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)UShortVector::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_600_4_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)UShortVector::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_600_5_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   UShortVector *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new UShortVector(*(UShortVector*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_UShortVector);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef UShortVector G__TUShortVector;
static int G__EventDict_600_6_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (UShortVector *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         ((UShortVector *)((G__getstructoffset())+sizeof(UShortVector)*i))->~G__TUShortVector();
   else {
     long G__Xtmp=G__getgvp();
     G__setgvp(G__PVOID);
     ((UShortVector *)(G__getstructoffset()))->~G__TUShortVector();
     G__setgvp(G__Xtmp);
     G__operator_delete((void*)G__getstructoffset());
   }
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_600_7_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   UShortVector *dest = (UShortVector*)(G__getstructoffset());
   *dest = (*(UShortVector*)libp->para[0].ref);
   const UShortVector& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EventHeader */
static int G__EventDict_605_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   EventHeader *p=NULL;
   if(G__getaryconstruct()) p=new EventHeader[G__getaryconstruct()];
   else p=::new((G__EventDictdOcxx_tag*)G__getgvp()) EventHeader;
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_EventHeader);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((EventHeader*)(G__getstructoffset()))->Set((Int_t)G__int(libp->para[0]),(Int_t)G__int(libp->para[1])
,(Int_t)G__int(libp->para[2]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const EventHeader*)(G__getstructoffset()))->GetEvtNum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const EventHeader*)(G__getstructoffset()))->GetRun());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_5_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const EventHeader*)(G__getstructoffset()))->GetDate());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_6_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)EventHeader::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_7_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)EventHeader::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_8_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)EventHeader::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_9_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      EventHeader::Dictionary();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_0_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const EventHeader*)(G__getstructoffset()))->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_1_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((EventHeader*)(G__getstructoffset()))->ShowMembers(*(TMemberInspector*)libp->para[0].ref,(char*)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_2_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((EventHeader*)(G__getstructoffset()))->Streamer(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_3_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((EventHeader*)(G__getstructoffset()))->StreamerNVirtual(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_4_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)EventHeader::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_5_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)EventHeader::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_6_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)EventHeader::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_605_7_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)EventHeader::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_605_8_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   EventHeader *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new EventHeader(*(EventHeader*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_EventHeader);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EventHeader G__TEventHeader;
static int G__EventDict_605_9_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (EventHeader *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         ((EventHeader *)((G__getstructoffset())+sizeof(EventHeader)*i))->~G__TEventHeader();
   else {
     long G__Xtmp=G__getgvp();
     G__setgvp(G__PVOID);
     ((EventHeader *)(G__getstructoffset()))->~G__TEventHeader();
     G__setgvp(G__Xtmp);
     G__operator_delete((void*)G__getstructoffset());
   }
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_605_0_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   EventHeader *dest = (EventHeader*)(G__getstructoffset());
   *dest = (*(EventHeader*)libp->para[0].ref);
   const EventHeader& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Event */
static int G__EventDict_606_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   Event *p=NULL;
   if(G__getaryconstruct()) p=new Event[G__getaryconstruct()];
   else                    p=new Event;
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_Event);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   Event *p=NULL;
      p = new Event((Int_t)G__int(libp->para[0]));
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_Event);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   switch(libp->paran) {
   case 1:
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->Clear((Option_t*)G__int(libp->para[0]));
      break;
   case 0:
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->Clear();
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      {
        const TDatime& obj=((Event*)(G__getstructoffset()))->GetDatime();
         result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_5_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   switch(libp->paran) {
   case 1:
      G__setnull(result7);
      Event::Reset((Option_t*)G__int(libp->para[0]));
      break;
   case 0:
      G__setnull(result7);
      Event::Reset();
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_6_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->ResetHistogramPointer();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_7_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetNseg((Int_t)G__int(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_8_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetNtrack((Int_t)G__int(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_9_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetNvertex((Int_t)G__int(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_0_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetFlag((UInt_t)G__int(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_1_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetTemperature((Float_t)G__double(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_2_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetType((char*)G__int(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_3_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetHeader((Int_t)G__int(libp->para[0]),(Int_t)G__int(libp->para[1])
,(Int_t)G__int(libp->para[2]),(Float_t)G__double(libp->para[3]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_4_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->AddTrack((Float_t)G__double(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_5_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetMeasure((UChar_t)G__int(libp->para[0]),(Int_t)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_6_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetMatrix((UChar_t)G__int(libp->para[0]),(UChar_t)G__int(libp->para[1])
,(Float_t)G__double(libp->para[2]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_7_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->SetRandomVertex();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_8_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->ShowLachaud();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_9_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)((Event*)(G__getstructoffset()))->GetType());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_0_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const Event*)(G__getstructoffset()))->GetNtrack());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_1_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const Event*)(G__getstructoffset()))->GetNseg());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_2_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const Event*)(G__getstructoffset()))->GetNvertex());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_3_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,104,(long)((const Event*)(G__getstructoffset()))->GetFlag());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_4_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Event*)(G__getstructoffset()))->GetTemperature());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_5_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((Event*)(G__getstructoffset()))->GetHeader());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_6_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const Event*)(G__getstructoffset()))->GetTracks());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_7_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const Event*)(G__getstructoffset()))->GetHistogram());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_8_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((Event*)(G__getstructoffset()))->GetMeasure((UChar_t)G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_9_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((Event*)(G__getstructoffset()))->GetMatrix((UChar_t)G__int(libp->para[0]),(UChar_t)G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_0_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((Event*)(G__getstructoffset()))->GetUshort());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_1_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)Event::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_2_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)Event::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_3_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)Event::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_4_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      Event::Dictionary();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_5_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const Event*)(G__getstructoffset()))->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_6_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->ShowMembers(*(TMemberInspector*)libp->para[0].ref,(char*)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_7_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->Streamer(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_8_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Event*)(G__getstructoffset()))->StreamerNVirtual(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_9_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)Event::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_0_4(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)Event::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_1_4(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)Event::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_606_2_4(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)Event::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Event G__TEvent;
static int G__EventDict_606_3_4(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (Event *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         delete (Event *)((G__getstructoffset())+sizeof(Event)*i);
   else  delete (Event *)(G__getstructoffset());
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* template1<int> */
// automatic default constructor
static int G__EventDict_645_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   template1<int> *p;
   if(G__getaryconstruct()) p=new template1<int>[G__getaryconstruct()];
   else p=::new((G__EventDictdOcxx_tag*)G__getgvp()) template1<int>;
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_template1lEintgR);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_645_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   template1<int> *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new template1<int>(*(template1<int>*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_template1lEintgR);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef template1<int> G__Ttemplate1lEintgR;
static int G__EventDict_645_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (template1<int> *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         ((template1<int> *)((G__getstructoffset())+sizeof(template1<int>)*i))->~G__Ttemplate1lEintgR();
   else {
     long G__Xtmp=G__getgvp();
     G__setgvp(G__PVOID);
     ((template1<int> *)(G__getstructoffset()))->~G__Ttemplate1lEintgR();
     G__setgvp(G__Xtmp);
     G__operator_delete((void*)G__getstructoffset());
   }
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_645_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   template1<int> *dest = (template1<int>*)(G__getstructoffset());
   const template1<int>& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* template2<template1<int> > */
// automatic default constructor
static int G__EventDict_646_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   template2<template1<int> > *p;
   if(G__getaryconstruct()) p=new template2<template1<int> >[G__getaryconstruct()];
   else p=::new((G__EventDictdOcxx_tag*)G__getgvp()) template2<template1<int> >;
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_646_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   template2<template1<int> > *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new template2<template1<int> >(*(template2<template1<int> >*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef template2<template1<int> > G__Ttemplate2lEtemplate1lEintgRsPgR;
static int G__EventDict_646_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (template2<template1<int> > *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         ((template2<template1<int> > *)((G__getstructoffset())+sizeof(template2<template1<int> >)*i))->~G__Ttemplate2lEtemplate1lEintgRsPgR();
   else {
     long G__Xtmp=G__getgvp();
     G__setgvp(G__PVOID);
     ((template2<template1<int> > *)(G__getstructoffset()))->~G__Ttemplate2lEtemplate1lEintgRsPgR();
     G__setgvp(G__Xtmp);
     G__operator_delete((void*)G__getstructoffset());
   }
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_646_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   template2<template1<int> > *dest = (template2<template1<int> >*)(G__getstructoffset());
   const template2<template1<int> >& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Track */
static int G__EventDict_725_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   Track *p=NULL;
   if(G__getaryconstruct()) p=new Track[G__getaryconstruct()];
   else                    p=new Track;
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_Track);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   Track *p=NULL;
      p = new Track((Float_t)G__double(libp->para[0]));
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_Track);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetPx());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetPy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_5_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetPz());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_6_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetPt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_7_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetRandom());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_8_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetBx());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_9_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetBy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_0_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetMass2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_1_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetMeanCharge());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_2_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetXfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_3_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetXlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_4_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetYfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_5_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetYlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_6_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetZfirst());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_7_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetZlast());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_8_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((const Track*)(G__getstructoffset()))->GetCharge());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_9_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   switch(libp->paran) {
   case 1:
      G__letdouble(result7,102,(double)((Track*)(G__getstructoffset()))->GetVertex((Int_t)G__int(libp->para[0])));
      break;
   case 0:
      G__letdouble(result7,102,(double)((Track*)(G__getstructoffset()))->GetVertex());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_0_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((Track*)(G__getstructoffset()))->GetCovar((Int_t)G__int(libp->para[0]),(Int_t)G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_1_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letdouble(result7,102,(double)((Track*)(G__getstructoffset()))->GetCovara((Int_t)G__int(libp->para[0]),(Int_t)G__int(libp->para[1])
,(Int_t)G__int(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_2_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)((const Track*)(G__getstructoffset()))->GetNpoint());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_3_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)((const Track*)(G__getstructoffset()))->GetValid());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_4_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   switch(libp->paran) {
   case 1:
      G__setnull(result7);
      ((Track*)(G__getstructoffset()))->SetValid((Int_t)G__int(libp->para[0]));
      break;
   case 0:
      G__setnull(result7);
      ((Track*)(G__getstructoffset()))->SetValid();
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_5_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)Track::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_6_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)Track::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_7_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)Track::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_8_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      Track::Dictionary();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_9_2(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const Track*)(G__getstructoffset()))->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_0_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Track*)(G__getstructoffset()))->ShowMembers(*(TMemberInspector*)libp->para[0].ref,(char*)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_1_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Track*)(G__getstructoffset()))->Streamer(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_2_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((Track*)(G__getstructoffset()))->StreamerNVirtual(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_3_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)Track::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_4_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)Track::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_5_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)Track::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_725_6_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)Track::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_725_7_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   Track *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new Track(*(Track*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_Track);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Track G__TTrack;
static int G__EventDict_725_8_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (Track *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         delete (Track *)((G__getstructoffset())+sizeof(Track)*i);
   else  delete (Track *)(G__getstructoffset());
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_725_9_3(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   Track *dest = (Track*)(G__getstructoffset());
   *dest = (*(Track*)libp->para[0].ref);
   const Track& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* BigTrack */
static int G__EventDict_726_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   BigTrack *p=NULL;
   if(G__getaryconstruct()) p=new BigTrack[G__getaryconstruct()];
   else                    p=new BigTrack;
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_BigTrack);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   BigTrack *p=NULL;
      p = new BigTrack((Float_t)G__double(libp->para[0]),(Int_t)G__int(libp->para[1]));
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_BigTrack);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)BigTrack::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)BigTrack::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_5_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)BigTrack::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_6_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      BigTrack::Dictionary();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_7_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const BigTrack*)(G__getstructoffset()))->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_8_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((BigTrack*)(G__getstructoffset()))->ShowMembers(*(TMemberInspector*)libp->para[0].ref,(char*)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_9_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((BigTrack*)(G__getstructoffset()))->Streamer(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_0_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((BigTrack*)(G__getstructoffset()))->StreamerNVirtual(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_1_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)BigTrack::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_2_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)BigTrack::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_3_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)BigTrack::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_726_4_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)BigTrack::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_726_5_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   BigTrack *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new BigTrack(*(BigTrack*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_BigTrack);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef BigTrack G__TBigTrack;
static int G__EventDict_726_6_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (BigTrack *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         delete (BigTrack *)((G__getstructoffset())+sizeof(BigTrack)*i);
   else  delete (BigTrack *)(G__getstructoffset());
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_726_7_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   BigTrack *dest = (BigTrack*)(G__getstructoffset());
   *dest = (*(BigTrack*)libp->para[0].ref);
   const BigTrack& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* HistogramManager */
static int G__EventDict_727_1_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   HistogramManager *p=NULL;
      p=::new((G__EventDictdOcxx_tag*)G__getgvp()) HistogramManager((TDirectory*)G__int(libp->para[0]));
      result7->obj.i = (long)p;
      result7->ref = (long)p;
      result7->type = 'u';
      result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_HistogramManager);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_2_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((HistogramManager*)(G__getstructoffset()))->Hfill((Event*)G__int(libp->para[0]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_3_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)HistogramManager::Class());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_4_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)HistogramManager::Class_Name());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_5_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,115,(long)HistogramManager::Class_Version());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_6_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      HistogramManager::Dictionary();
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_7_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,85,(long)((const HistogramManager*)(G__getstructoffset()))->IsA());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_8_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((HistogramManager*)(G__getstructoffset()))->ShowMembers(*(TMemberInspector*)libp->para[0].ref,(char*)G__int(libp->para[1]));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_9_0(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((HistogramManager*)(G__getstructoffset()))->Streamer(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_0_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__setnull(result7);
      ((HistogramManager*)(G__getstructoffset()))->StreamerNVirtual(*(TBuffer*)libp->para[0].ref);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_1_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)HistogramManager::DeclFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_2_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)HistogramManager::ImplFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_3_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   G__letint(result7,67,(long)HistogramManager::ImplFileName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__EventDict_727_4_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
      G__letint(result7,105,(long)HistogramManager::DeclFileLine());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__EventDict_727_5_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash)
{
   HistogramManager *p;
   void *xtmp = (void*)G__int(libp->para[0]);
   p=new HistogramManager(*(HistogramManager*)xtmp);
   result7->obj.i = (long)p;
   result7->ref = (long)p;
   result7->type = 'u';
   result7->tagnum = G__get_linked_tagnum(&G__EventDictLN_HistogramManager);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef HistogramManager G__THistogramManager;
static int G__EventDict_727_6_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   if(0==G__getstructoffset()) return(1);
   if(G__getaryconstruct())
     if(G__PVOID==G__getgvp())
       delete[] (HistogramManager *)(G__getstructoffset());
     else
       for(int i=G__getaryconstruct()-1;i>=0;i--)
         ((HistogramManager *)((G__getstructoffset())+sizeof(HistogramManager)*i))->~G__THistogramManager();
   else {
     long G__Xtmp=G__getgvp();
     G__setgvp(G__PVOID);
     ((HistogramManager *)(G__getstructoffset()))->~G__THistogramManager();
     G__setgvp(G__Xtmp);
     G__operator_delete((void*)G__getstructoffset());
   }
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__EventDict_727_7_1(G__value *result7,G__CONST char *funcname,struct G__param *libp,int hash) {
   HistogramManager *dest = (HistogramManager*)(G__getstructoffset());
   *dest = (*(HistogramManager*)libp->para[0].ref);
   const HistogramManager& obj = *dest;
   result7->ref=(long)(&obj); result7->obj.i=(long)(&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* UShortVector */

/* EventHeader */

/* Event */

/* template1<int> */

/* template2<template1<int> > */

/* Track */

/* BigTrack */

/* HistogramManager */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncEventDict {
 public:
  G__Sizep2memfuncEventDict() {p=&G__Sizep2memfuncEventDict::sizep2memfunc;}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncEventDict::*p)();
};

size_t G__get_sizep2memfuncEventDict()
{
  G__Sizep2memfuncEventDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceEventDict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__EventDictLN_UShortVector))) {
     UShortVector *G__Lderived;
     G__Lderived=(UShortVector*)0x1000;
     {
       vector<unsigned short,allocator<unsigned short> > *G__Lpbase=(vector<unsigned short,allocator<unsigned short> >*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__EventDictLN_UShortVector),G__get_linked_tagnum(&G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__EventDictLN_Event))) {
     Event *G__Lderived;
     G__Lderived=(Event*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__EventDictLN_Event),G__get_linked_tagnum(&G__EventDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__EventDictLN_Track))) {
     Track *G__Lderived;
     G__Lderived=(Track*)0x1000;
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__EventDictLN_Track),G__get_linked_tagnum(&G__EventDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__EventDictLN_BigTrack))) {
     BigTrack *G__Lderived;
     G__Lderived=(BigTrack*)0x1000;
     {
       Track *G__Lpbase=(Track*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__EventDictLN_BigTrack),G__get_linked_tagnum(&G__EventDictLN_Track),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       TObject *G__Lpbase=(TObject*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__EventDictLN_BigTrack),G__get_linked_tagnum(&G__EventDictLN_TObject),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableEventDict() {

   /* Setting up typedef entry */
   G__search_typename2("UChar_t",98,-1,0,
-1);
   G__setnewtype(-1,"Unsigned Character 1 byte (unsigned char)",0);
   G__search_typename2("Short_t",115,-1,0,
-1);
   G__setnewtype(-1,"Signed Short integer 2 bytes (short)",0);
   G__search_typename2("Int_t",105,-1,0,
-1);
   G__setnewtype(-1,"Signed integer 4 bytes (int)",0);
   G__search_typename2("UInt_t",104,-1,0,
-1);
   G__setnewtype(-1,"Unsigned integer 4 bytes (unsigned int)",0);
   G__search_typename2("Float_t",102,-1,0,
-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("Version_t",115,-1,0,
-1);
   G__setnewtype(-1,"Class version identifier (short)",0);
   G__search_typename2("Option_t",99,-1,256,
-1);
   G__setnewtype(-1,"Option string (const char)",0);
   G__search_typename2("vector<UShort_t>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<unsigned short>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<Long64_t>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlElongsPlongcOallocatorlElongsPlonggRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlElongsPlongcOallocatorlElongsPlonggRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<long long>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<Int_t>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<TLine>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETLinecOallocatorlETLinegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETLinecOallocatorlETLinegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<TObject>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETObjectcOallocatorlETObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETObjectcOallocatorlETObjectgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<TNamed>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETNamedcOallocatorlETNamedgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETNamedcOallocatorlETNamedgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("deque<TAttLine>",117,G__get_linked_tagnum(&G__EventDictLN_dequelETAttLinecOallocatorlETAttLinegRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("list<const TObject*>",117,G__get_linked_tagnum(&G__EventDictLN_listlEconstsPTObjectmUcOallocatorlEconstsPTObjectmUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("list<string*>",117,G__get_linked_tagnum(&G__EventDictLN_listlEstringmUcOallocatorlEstringmUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TNamed*,int>",117,G__get_linked_tagnum(&G__EventDictLN_maplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TNamed*,int>less<TNamed*>>",117,G__get_linked_tagnum(&G__EventDictLN_maplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TString,TList*>",117,G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTListmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTListmUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TString,TList*>less<TString>>",117,G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTListmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTListmUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TString,TString*>",117,G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTStringmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTStringmUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TString,TString*>less<TString>>",117,G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTStringmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTStringmUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<EventHeader,TString*>",117,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringmUcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringmUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<EventHeader,TString*>less<EventHeader>>",117,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringmUcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringmUgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<EventHeader,TString>",117,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<EventHeader,TString>less<EventHeader>>",117,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<EventHeader,string>",117,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOstringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOstringgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<EventHeader,string>less<EventHeader>>",117,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOstringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOstringgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TAxis*,int>",117,G__get_linked_tagnum(&G__EventDictLN_maplETAxismUcOintcOlesslETAxismUgRcOallocatorlEpairlEconstsPTAxismUcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<TAxis*,int>less<TAxis*>>",117,G__get_linked_tagnum(&G__EventDictLN_maplETAxismUcOintcOlesslETAxismUgRcOallocatorlEpairlEconstsPTAxismUcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("set<TAxis*>",117,G__get_linked_tagnum(&G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("set<TAxis*>less<TAxis*>>",117,G__get_linked_tagnum(&G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("multimap<TNamed*,int>",117,G__get_linked_tagnum(&G__EventDictLN_multimaplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("multimap<TNamed*,int>less<TNamed*>>",117,G__get_linked_tagnum(&G__EventDictLN_multimaplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("multiset<TAxis*>",117,G__get_linked_tagnum(&G__EventDictLN_multisetlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("multiset<TAxis*>less<TAxis*>>",117,G__get_linked_tagnum(&G__EventDictLN_multisetlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<TAxis*>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlETAxismUcOallocatorlETAxismUgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETAxismUcOallocatorlETAxismUgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlETAxismUcOallocatorlETAxismUgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<vector<TAxis*> >",117,G__get_linked_tagnum(&G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR));
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("vector<vector<TAxis*,allocator<TAxis*> >>",117,G__get_linked_tagnum(&G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<string,vector<int> >",117,G__get_linked_tagnum(&G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<string,vector<int,allocator<int> >>",117,G__get_linked_tagnum(&G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("map<string,vector<int,allocator<int> >>less<string>>",117,G__get_linked_tagnum(&G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("deque<pair<float,float> >",117,G__get_linked_tagnum(&G__EventDictLN_dequelEpairlEfloatcOfloatgRcOallocatorlEpairlEfloatcOfloatgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
   G__search_typename2("deque<pair<float,float>>",117,G__get_linked_tagnum(&G__EventDictLN_dequelEpairlEfloatcOfloatgRcOallocatorlEpairlEfloatcOfloatgRsPgRsPgR),0,-1);
   G__setnewtype(-1,"// @(#)root/base:$Name:  $:$Id: TROOT.h,v 1.40 2004/02/19 00:11:18 rdm Exp $",0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* UShortVector */
static void G__setup_memvarUShortVector(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_UShortVector));
   { UShortVector *p; p=(UShortVector*)0x1000; if (p) { }
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fNshorts=",0,"length of STL std::vector (duplicated info)");
   G__memvar_setup((void*)NULL,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* EventHeader */
static void G__setup_memvarEventHeader(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_EventHeader));
   { EventHeader *p; p=(EventHeader*)0x1000; if (p) { }
   G__memvar_setup((void*)NULL,100,0,0,-1,G__defined_typename("Double_t"),-2,4,"fgNever=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fEvtNum)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fEvtNum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fRun)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fRun=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->fDate)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"fDate=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Event */
static void G__setup_memvarEvent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_Event));
   { Event *p; p=(Event*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__EventDictLN_EventcLcLdA),-1,-2,1,"kSize=10",0,(char*)NULL);
   G__memvar_setup((void*)NULL,99,0,0,-1,-1,-1,4,"fType[20]=",0,"array of 20 chars");
   G__memvar_setup((void*)NULL,67,0,0,-1,-1,-1,4,"fEventName=",0,"run+event number in character format");
   G__memvar_setup((void*)NULL,103,0,0,-1,G__defined_typename("Bool_t"),-1,4,"fBoolA=",0,"boolean flag");
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fNtrack=",0,"number of tracks");
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fNseg=",0,"number of segments");
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fNvertex=",0,"number of vertices");
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fMeasures[10]=",0,"an array where dimension is an enum");
   G__memvar_setup((void*)NULL,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"fFlag=",0,"bit pattern event flag");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fMatrix[4][4]=",0,"a two-dim array");
   G__memvar_setup((void*)NULL,70,0,0,-1,G__defined_typename("Float_t"),-1,4,"fClosestDistance=",0,"[fNvertex] pointer to an array of floats of length fNvertex ");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fTemperature=",0,"event temperature");
   G__memvar_setup((void*)NULL,67,0,0,-1,-1,-1,4,"fTracksInVertex=",0,"[fNvertex]");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR),G__defined_typename("vector<Long64_t>"),-1,4,"fVectorLong64=",0,"STL vector on ints");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<Int_t>"),-1,4,"fVectorint2=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<int>"),-1,4,"fVectorint=",0,"STL vector on ints");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEshortcOallocatorlEshortgRsPgR),G__defined_typename("vector<short>"),-1,4,"fVectorshort=",0,"STL vector of shorts");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),G__defined_typename("vector<double>"),-1,4,"fVectorD[4]=",0,"array of STL vectors of doubles");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR),G__defined_typename("vector<TLine>"),-1,4,"fVectorTLine=",0,"|| array of STL vectors of TLine objects");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR),G__defined_typename("vector<TObject>"),-1,4,"fVectorTobject=",0,"|| pointer to an STL vector");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR),G__defined_typename("vector<TNamed>"),-1,4,"fVectorTnamed[6]=",0,"|| array of pointers to STL vectors");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEstringcOallocatorlEstringgRsPgR),G__defined_typename("vector<string>"),-1,4,"fLachaud=",0,"an STL vector of strings");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_dequelETAttLinecOallocatorlETAttLinegRsPgR),G__defined_typename("deque<TAttLine>"),-1,4,"fDeque=",0,"STL deque");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_listlEconstsPTObjectmUcOallocatorlEconstsPTObjectmUgRsPgR),G__defined_typename("list<const TObject*>"),-1,4,"fVectorTobjectp=",0,"STL list of pointers to objects");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_listlEstringcOallocatorlEstringgRsPgR),G__defined_typename("list<string>"),-1,4,"fListString=",0,"STL list of strings");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_listlEstringmUcOallocatorlEstringmUgRsPgR),G__defined_typename("list<string*>"),-1,4,"fListStringp=",0,"STL list of pointers to strings");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR),G__defined_typename("map<TNamed*,int>"),-1,4,"fMapTNamedp=",0,"STL map");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR),-1,-1,4,"fTemplateMember=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTListmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTListmUgRsPgRsPgR),G__defined_typename("map<TString,TList*>"),-1,4,"fMapList=",0,"STL map");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTStringmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTStringmUgRsPgRsPgR),G__defined_typename("map<TString,TString*>"),-1,4,"fMapTString=",0,"!STL map");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringmUcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringmUgRsPgRsPgR),G__defined_typename("map<EventHeader,TString*>"),-1,4,"fMapHeaderP=",0,"!STL map");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringgRsPgRsPgR),G__defined_typename("map<EventHeader,TString>"),-1,4,"fMapHeader=",0,"!STL map");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOstringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOstringgRsPgRsPgR),G__defined_typename("map<EventHeader,string>"),-1,4,"fMapHeaderst=",0,"!STL map");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_maplETAxismUcOintcOlesslETAxismUgRcOallocatorlEpairlEconstsPTAxismUcOintgRsPgRsPgR),G__defined_typename("map<TAxis*,int>"),-1,4,"fMapTAxisp=",0,"pointer to STL map");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),G__defined_typename("set<TAxis*>"),-1,4,"fSetTAxis=",0,"STL set");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),G__defined_typename("set<TAxis*>"),-1,4,"fSetTAxisp=",0,"pointer to STL set");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_multimaplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR),G__defined_typename("multimap<TNamed*,int>"),-1,4,"fMultiMapTNamedp=",0,"STL multimap");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_multisetlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR),G__defined_typename("multiset<TAxis*>"),-1,4,"fMultiSetTAxisp=",0,"pointer to STL multiset");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR),G__defined_typename("vector<vector<TAxis*> >"),-1,4,"fVectAxis=",0,"!STL vector of vectors of TAxis*");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),G__defined_typename("map<string,vector<int> >"),-1,4,"fMapString=",0,"!STL map of string/vector");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_dequelEpairlEfloatcOfloatgRcOallocatorlEpairlEfloatcOfloatgRsPgRsPgR),G__defined_typename("deque<pair<float,float> >"),-1,4,"fDequePair=",0,"!STL deque of pair");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_string),-1,-1,4,"fString=",0,"C++ standard string");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_string),-1,-1,4,"fStringp=",0,"pointer to standard C++ string");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TString),-1,-1,4,"fTstringp=",0,"[fNvertex] array of TString");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TString),-1,-1,4,"fNames[12]=",0,"array of TString");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TAxis),-1,-1,4,"fXaxis=",0,"example of class derived from TObject");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TAxis),-1,-1,4,"fYaxis[3]=",0,"array of objects");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TAxis),-1,-1,4,"fVaxis[3]=",0,"pointer to an array of TAxis");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TAxis),-1,-1,4,"fPaxis=",0,"[fNvertex] pointer to an array of TAxis of length fNvertex");
   G__memvar_setup((void*)NULL,85,2,0,G__get_linked_tagnum(&G__EventDictLN_TAxis),-1,-1,4,"fQaxis=",0,"[fNvertex] pointer to an array of pointers to TAxis objects");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TDatime),-1,-1,4,"fDatime=",0,"date and time");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_EventHeader),-1,-1,4,"fEvtHdr=",0,"example of class not derived from TObject");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TObjArray),-1,-1,4,"fObjArray=",0,"An object array of TObject*");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClonesArray),-1,-1,4,"fTracks=",0,"-> array of tracks");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fH=",0,"-> pointer to an histogram");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TLorentzVector),-1,-1,4,"fLorentz=",0,"to test lorentzvector at top level");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TArrayF),-1,-1,4,"fArrayF=",0,"an array of floats");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TArrayI),-1,-1,4,"fArrayI=",0,"a pointer to an array of integers");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_UShortVector),-1,-1,4,"fUshort=",0,"a TObject with an STL vector as base class");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TRef),-1,-1,4,"fRefH=",0,"Reference link to fH");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClonesArray),-1,-2,4,"fgTracks=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-2,4,"fgHist=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* template1<int> */
static void G__setup_memvartemplate1lEintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_template1lEintgR));
   { template1<int> *p; p=(template1<int>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* template2<template1<int> > */
static void G__setup_memvartemplate2lEtemplate1lEintgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR));
   { template2<template1<int> > *p; p=(template2<template1<int> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* Track */
static void G__setup_memvarTrack(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_Track));
   { Track *p; p=(Track*)0x1000; if (p) { }
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fPx=",0,"X component of the momentum");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fPy=",0,"Y component of the momentum");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fPz=",0,"Z component of the momentum");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fRandom=",0,"A random track quantity");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fMass2=",0,"The mass square of this particle");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fBx=",0,"X intercept at the vertex");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fBy=",0,"Y intercept at the vertex");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fMeanCharge=",0,"Mean charge deposition of all hits of this track");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fXfirst=",0,"X coordinate of the first point");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fXlast=",0,"X coordinate of the last point");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fYfirst=",0,"Y coordinate of the first point");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fYlast=",0,"Y coordinate of the last point");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fZfirst=",0,"Z coordinate of the first point");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fZlast=",0,"Z coordinate of the last point");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<int>"),-1,4,"fHits=",0,"list of hits");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fCharge=",0,"Charge of this track");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fVertex[3]=",0,"Track vertex position");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fCovar[3][4]=",0,"Covariance matrix");
   G__memvar_setup((void*)NULL,102,0,0,-1,G__defined_typename("Float_t"),-1,4,"fCovara[3][4][2]=",0,"Covariance matrix");
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fNpoint=",0,"Number of points for this track");
   G__memvar_setup((void*)NULL,115,0,0,-1,G__defined_typename("Short_t"),-1,4,"fValid=",0,"Validity criterion");
   G__memvar_setup((void*)NULL,83,0,0,-1,G__defined_typename("Short_t"),-1,4,"fPoints=",0,"[fNpoint] List of points");
   G__memvar_setup((void*)NULL,67,0,0,-1,-1,-1,4,"fTrackName=",0,"Track name");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TArrayI),-1,-1,4,"fInts=",0,"some integers");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* BigTrack */
static void G__setup_memvarBigTrack(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_BigTrack));
   { BigTrack *p; p=(BigTrack*)0x1000; if (p) { }
   G__memvar_setup((void*)NULL,105,0,0,-1,G__defined_typename("Int_t"),-1,4,"fSpecial=",0,"The BigTrack validity flag");
   G__memvar_setup((void*)NULL,117,0,0,G__get_linked_tagnum(&G__EventDictLN_TLorentzVector),-1,-1,4,"fKine=",0,"more kinematics");
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* HistogramManager */
static void G__setup_memvarHistogramManager(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__EventDictLN_HistogramManager));
   { HistogramManager *p; p=(HistogramManager*)0x1000; if (p) { }
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fNtrack=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fNseg=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fTemperature=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fPx=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fPy=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fPz=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fRandom=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fMass2=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fBx=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fBy=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fMeanCharge=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fXfirst=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fXlast=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fYfirst=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fYlast=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fZfirst=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fZlast=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fCharge=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fNpoint=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,-1,4,"fValid=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)NULL,85,0,0,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,-2,4,"fgIsA=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarEventDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncUShortVector(void) {
   /* UShortVector */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_UShortVector));
   G__memfunc_setup("UShortVector",1240,G__EventDict_600_1_0,105,G__get_linked_tagnum(&G__EventDictLN_UShortVector),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("UShortVector",1240,G__EventDict_600_2_0,105,G__get_linked_tagnum(&G__EventDictLN_UShortVector),-1,0,1,1,1,0,"i - 'Int_t' 0 - n",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Class",502,G__EventDict_600_3_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,3,1,0,"",(char*)NULL,(void*)(TClass* (*)())(&UShortVector::Class),0);
   G__memfunc_setup("Class_Name",982,G__EventDict_600_4_0,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&UShortVector::Class_Name),0);
   G__memfunc_setup("Class_Version",1339,G__EventDict_600_5_0,115,-1,G__defined_typename("Version_t"),0,0,3,1,0,"",(char*)NULL,(void*)(Version_t (*)())(&UShortVector::Class_Version),0);
   G__memfunc_setup("Dictionary",1046,G__EventDict_600_6_0,121,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(void (*)())(&UShortVector::Dictionary),0);
   G__memfunc_setup("IsA",253,G__EventDict_600_7_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("ShowMembers",1132,G__EventDict_600_8_0,121,-1,-1,0,2,1,1,0,
"u 'TMemberInspector' - 1 - insp C - - 0 - parent",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Streamer",835,G__EventDict_600_9_0,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("StreamerNVirtual",1656,G__EventDict_600_0_1,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("DeclFileName",1145,G__EventDict_600_1_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&UShortVector::DeclFileName),0);
   G__memfunc_setup("ImplFileLine",1178,G__EventDict_600_2_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&UShortVector::ImplFileLine),0);
   G__memfunc_setup("ImplFileName",1171,G__EventDict_600_3_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&UShortVector::ImplFileName),0);
   G__memfunc_setup("DeclFileLine",1152,G__EventDict_600_4_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&UShortVector::DeclFileLine),0);
   // automatic copy constructor
   G__memfunc_setup("UShortVector",1240,G__EventDict_600_5_1,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_UShortVector),-1,0,1,1,1,0,"u 'UShortVector' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~UShortVector",1366,G__EventDict_600_6_1,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,1);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_600_7_1,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_UShortVector),-1,1,1,1,1,0,"u 'UShortVector' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEventHeader(void) {
   /* EventHeader */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_EventHeader));
   G__memfunc_setup("EventHeader",1099,G__EventDict_605_1_0,105,G__get_linked_tagnum(&G__EventDictLN_EventHeader),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Set",300,G__EventDict_605_2_0,121,-1,-1,0,3,1,1,0,
"i - 'Int_t' 0 - i i - 'Int_t' 0 - r "
"i - 'Int_t' 0 - d",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetEvtNum",895,G__EventDict_605_3_0,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetRun",597,G__EventDict_605_4_0,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetDate",670,G__EventDict_605_5_0,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Class",502,G__EventDict_605_6_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,3,1,0,"",(char*)NULL,(void*)(TClass* (*)())(&EventHeader::Class),0);
   G__memfunc_setup("Class_Name",982,G__EventDict_605_7_0,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&EventHeader::Class_Name),0);
   G__memfunc_setup("Class_Version",1339,G__EventDict_605_8_0,115,-1,G__defined_typename("Version_t"),0,0,3,1,0,"",(char*)NULL,(void*)(Version_t (*)())(&EventHeader::Class_Version),0);
   G__memfunc_setup("Dictionary",1046,G__EventDict_605_9_0,121,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(void (*)())(&EventHeader::Dictionary),0);
   G__memfunc_setup("IsA",253,G__EventDict_605_0_1,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("ShowMembers",1132,G__EventDict_605_1_1,121,-1,-1,0,2,1,1,0,
"u 'TMemberInspector' - 1 - insp C - - 0 - parent",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Streamer",835,G__EventDict_605_2_1,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("StreamerNVirtual",1656,G__EventDict_605_3_1,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("DeclFileName",1145,G__EventDict_605_4_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&EventHeader::DeclFileName),0);
   G__memfunc_setup("ImplFileLine",1178,G__EventDict_605_5_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&EventHeader::ImplFileLine),0);
   G__memfunc_setup("ImplFileName",1171,G__EventDict_605_6_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&EventHeader::ImplFileName),0);
   G__memfunc_setup("DeclFileLine",1152,G__EventDict_605_7_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&EventHeader::DeclFileLine),0);
   // automatic copy constructor
   G__memfunc_setup("EventHeader",1099,G__EventDict_605_8_1,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_EventHeader),-1,0,1,1,1,0,"u 'EventHeader' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~EventHeader",1225,G__EventDict_605_9_1,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,1);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_605_0_2,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_EventHeader),-1,1,1,1,1,0,"u 'EventHeader' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEvent(void) {
   /* Event */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_Event));
   G__memfunc_setup("Event",514,G__EventDict_606_1_0,105,G__get_linked_tagnum(&G__EventDictLN_Event),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Event",514,G__EventDict_606_2_0,105,G__get_linked_tagnum(&G__EventDictLN_Event),-1,0,1,1,1,0,"i - 'Int_t' 0 - i",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Clear",487,G__EventDict_606_3_0,121,-1,-1,0,1,1,1,0,"C - 'Option_t' 10 \"\" option",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("GetDatime",884,G__EventDict_606_4_0,117,G__get_linked_tagnum(&G__EventDictLN_TDatime),-1,1,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Reset",515,G__EventDict_606_5_0,121,-1,-1,0,1,3,1,0,"C - 'Option_t' 10 \"\" option",(char*)NULL,(void*)(void (*)(Option_t*))(&Event::Reset),0);
   G__memfunc_setup("ResetHistogramPointer",2194,G__EventDict_606_6_0,121,-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetNseg",697,G__EventDict_606_7_0,121,-1,-1,0,1,1,1,0,"i - 'Int_t' 0 - n",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetNtrack",911,G__EventDict_606_8_0,121,-1,-1,0,1,1,1,0,"i - 'Int_t' 0 - n",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetNvertex",1048,G__EventDict_606_9_0,121,-1,-1,0,1,1,1,0,"i - 'Int_t' 0 - n",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetFlag",678,G__EventDict_606_0_1,121,-1,-1,0,1,1,1,0,"h - 'UInt_t' 0 - f",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetTemperature",1466,G__EventDict_606_1_1,121,-1,-1,0,1,1,1,0,"f - 'Float_t' 0 - t",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetType",718,G__EventDict_606_2_1,121,-1,-1,0,1,1,1,0,"C - - 0 - type",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetHeader",885,G__EventDict_606_3_1,121,-1,-1,0,4,1,1,0,
"i - 'Int_t' 0 - i i - 'Int_t' 0 - run "
"i - 'Int_t' 0 - date f - 'Float_t' 0 - random",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("AddTrack",766,G__EventDict_606_4_1,121,-1,-1,0,1,1,1,0,"f - 'Float_t' 0 - random",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetMeasure",1022,G__EventDict_606_5_1,121,-1,-1,0,2,1,1,0,
"b - 'UChar_t' 0 - which i - 'Int_t' 0 - what",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetMatrix",929,G__EventDict_606_6_1,121,-1,-1,0,3,1,1,0,
"b - 'UChar_t' 0 - x b - 'UChar_t' 0 - y "
"f - 'Float_t' 0 - what",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetRandomVertex",1547,G__EventDict_606_7_1,121,-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("ShowLachaud",1107,G__EventDict_606_8_1,121,-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetType",706,G__EventDict_606_9_1,67,-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetNtrack",899,G__EventDict_606_0_2,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetNseg",685,G__EventDict_606_1_2,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetNvertex",1036,G__EventDict_606_2_2,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetFlag",666,G__EventDict_606_3_2,104,-1,G__defined_typename("UInt_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetTemperature",1454,G__EventDict_606_4_2,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetHeader",873,G__EventDict_606_5_2,85,G__get_linked_tagnum(&G__EventDictLN_EventHeader),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetTracks",904,G__EventDict_606_6_2,85,G__get_linked_tagnum(&G__EventDictLN_TClonesArray),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetHistogram",1230,G__EventDict_606_7_2,85,G__get_linked_tagnum(&G__EventDictLN_TH1F),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetMeasure",1010,G__EventDict_606_8_2,105,-1,G__defined_typename("Int_t"),0,1,1,1,0,"b - 'UChar_t' 0 - which",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetMatrix",917,G__EventDict_606_9_2,102,-1,G__defined_typename("Float_t"),0,2,1,1,0,
"b - 'UChar_t' 0 - x b - 'UChar_t' 0 - y",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetUshort",933,G__EventDict_606_0_3,85,G__get_linked_tagnum(&G__EventDictLN_UShortVector),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Class",502,G__EventDict_606_1_3,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,3,1,0,"",(char*)NULL,(void*)(TClass* (*)())(&Event::Class),0);
   G__memfunc_setup("Class_Name",982,G__EventDict_606_2_3,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&Event::Class_Name),0);
   G__memfunc_setup("Class_Version",1339,G__EventDict_606_3_3,115,-1,G__defined_typename("Version_t"),0,0,3,1,0,"",(char*)NULL,(void*)(Version_t (*)())(&Event::Class_Version),0);
   G__memfunc_setup("Dictionary",1046,G__EventDict_606_4_3,121,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(void (*)())(&Event::Dictionary),0);
   G__memfunc_setup("IsA",253,G__EventDict_606_5_3,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("ShowMembers",1132,G__EventDict_606_6_3,121,-1,-1,0,2,1,1,0,
"u 'TMemberInspector' - 1 - insp C - - 0 - parent",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Streamer",835,G__EventDict_606_7_3,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("StreamerNVirtual",1656,G__EventDict_606_8_3,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("DeclFileName",1145,G__EventDict_606_9_3,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&Event::DeclFileName),0);
   G__memfunc_setup("ImplFileLine",1178,G__EventDict_606_0_4,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&Event::ImplFileLine),0);
   G__memfunc_setup("ImplFileName",1171,G__EventDict_606_1_4,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&Event::ImplFileName),0);
   G__memfunc_setup("DeclFileLine",1152,G__EventDict_606_2_4,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&Event::DeclFileLine),0);
   // automatic destructor
   G__memfunc_setup("~Event",640,G__EventDict_606_3_4,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,1);
   G__tag_memfunc_reset();
}

static void G__setup_memfunctemplate1lEintgR(void) {
   /* template1<int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_template1lEintgR));
   // automatic default constructor
   G__memfunc_setup("template1<int>",1362,G__EventDict_645_1_0,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_template1lEintgR),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   // automatic copy constructor
   G__memfunc_setup("template1<int>",1362,G__EventDict_645_2_0,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_template1lEintgR),-1,0,1,1,1,0,"u 'template1<int>' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~template1<int>",1488,G__EventDict_645_3_0,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_645_4_0,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_template1lEintgR),-1,1,1,1,1,0,"u 'template1<int>' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}

static void G__setup_memfunctemplate2lEtemplate1lEintgRsPgR(void) {
   /* template2<template1<int> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR));
   // automatic default constructor
   G__memfunc_setup("template2<template1<int> >",2426,G__EventDict_646_1_0,(int)('i'),
G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   // automatic copy constructor
   G__memfunc_setup("template2<template1<int> >",2426,G__EventDict_646_2_0,(int)('i'),
G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR),-1,0,1,1,1,0,"u 'template2<template1<int> >' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~template2<template1<int> >",2552,G__EventDict_646_3_0,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_646_4_0,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR),-1,1,1,1,1,0,"u 'template2<template1<int> >' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrack(void) {
   /* Track */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_Track));
   G__memfunc_setup("Track",501,G__EventDict_725_1_0,105,G__get_linked_tagnum(&G__EventDictLN_Track),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Track",501,G__EventDict_725_2_0,105,G__get_linked_tagnum(&G__EventDictLN_Track),-1,0,1,1,1,0,"f - 'Float_t' 0 - random",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetPx",488,G__EventDict_725_3_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetPy",489,G__EventDict_725_4_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetPz",490,G__EventDict_725_5_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetPt",484,G__EventDict_725_6_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetRandom",897,G__EventDict_725_7_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetBx",474,G__EventDict_725_8_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetBy",475,G__EventDict_725_9_0,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetMass2",742,G__EventDict_725_0_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetMeanCharge",1259,G__EventDict_725_1_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetXfirst",928,G__EventDict_725_2_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetXlast",812,G__EventDict_725_3_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetYfirst",929,G__EventDict_725_4_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetYlast",813,G__EventDict_725_5_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetZfirst",930,G__EventDict_725_6_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetZlast",814,G__EventDict_725_7_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetCharge",874,G__EventDict_725_8_1,102,-1,G__defined_typename("Float_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetVertex",926,G__EventDict_725_9_1,102,-1,G__defined_typename("Float_t"),0,1,1,1,0,"i - 'Int_t' 0 0 i",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetCovar",795,G__EventDict_725_0_2,102,-1,G__defined_typename("Float_t"),0,2,1,1,0,
"i - 'Int_t' 0 - i i - 'Int_t' 0 - j",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetCovara",892,G__EventDict_725_1_2,102,-1,G__defined_typename("Float_t"),0,3,1,1,0,
"i - 'Int_t' 0 - i i - 'Int_t' 0 - j "
"i - 'Int_t' 0 - k",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetNpoint",920,G__EventDict_725_2_2,105,-1,G__defined_typename("Int_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("GetValid",784,G__EventDict_725_3_2,115,-1,G__defined_typename("Short_t"),0,0,1,1,8,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("SetValid",796,G__EventDict_725_4_2,121,-1,-1,0,1,1,1,0,"i - 'Int_t' 0 1 valid",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Class",502,G__EventDict_725_5_2,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,3,1,0,"",(char*)NULL,(void*)(TClass* (*)())(&Track::Class),0);
   G__memfunc_setup("Class_Name",982,G__EventDict_725_6_2,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&Track::Class_Name),0);
   G__memfunc_setup("Class_Version",1339,G__EventDict_725_7_2,115,-1,G__defined_typename("Version_t"),0,0,3,1,0,"",(char*)NULL,(void*)(Version_t (*)())(&Track::Class_Version),0);
   G__memfunc_setup("Dictionary",1046,G__EventDict_725_8_2,121,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(void (*)())(&Track::Dictionary),0);
   G__memfunc_setup("IsA",253,G__EventDict_725_9_2,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("ShowMembers",1132,G__EventDict_725_0_3,121,-1,-1,0,2,1,1,0,
"u 'TMemberInspector' - 1 - insp C - - 0 - parent",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Streamer",835,G__EventDict_725_1_3,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("StreamerNVirtual",1656,G__EventDict_725_2_3,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("DeclFileName",1145,G__EventDict_725_3_3,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&Track::DeclFileName),0);
   G__memfunc_setup("ImplFileLine",1178,G__EventDict_725_4_3,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&Track::ImplFileLine),0);
   G__memfunc_setup("ImplFileName",1171,G__EventDict_725_5_3,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&Track::ImplFileName),0);
   G__memfunc_setup("DeclFileLine",1152,G__EventDict_725_6_3,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&Track::DeclFileLine),0);
   // automatic copy constructor
   G__memfunc_setup("Track",501,G__EventDict_725_7_3,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_Track),-1,0,1,1,1,0,"u 'Track' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~Track",627,G__EventDict_725_8_3,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,1);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_725_9_3,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_Track),-1,1,1,1,1,0,"u 'Track' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncBigTrack(void) {
   /* BigTrack */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_BigTrack));
   G__memfunc_setup("BigTrack",775,G__EventDict_726_1_0,105,G__get_linked_tagnum(&G__EventDictLN_BigTrack),-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("BigTrack",775,G__EventDict_726_2_0,105,G__get_linked_tagnum(&G__EventDictLN_BigTrack),-1,0,2,1,1,0,
"f - 'Float_t' 0 - random i - 'Int_t' 0 - special",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Class",502,G__EventDict_726_3_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,3,1,0,"",(char*)NULL,(void*)(TClass* (*)())(&BigTrack::Class),0);
   G__memfunc_setup("Class_Name",982,G__EventDict_726_4_0,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&BigTrack::Class_Name),0);
   G__memfunc_setup("Class_Version",1339,G__EventDict_726_5_0,115,-1,G__defined_typename("Version_t"),0,0,3,1,0,"",(char*)NULL,(void*)(Version_t (*)())(&BigTrack::Class_Version),0);
   G__memfunc_setup("Dictionary",1046,G__EventDict_726_6_0,121,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(void (*)())(&BigTrack::Dictionary),0);
   G__memfunc_setup("IsA",253,G__EventDict_726_7_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("ShowMembers",1132,G__EventDict_726_8_0,121,-1,-1,0,2,1,1,0,
"u 'TMemberInspector' - 1 - insp C - - 0 - parent",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Streamer",835,G__EventDict_726_9_0,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("StreamerNVirtual",1656,G__EventDict_726_0_1,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("DeclFileName",1145,G__EventDict_726_1_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&BigTrack::DeclFileName),0);
   G__memfunc_setup("ImplFileLine",1178,G__EventDict_726_2_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&BigTrack::ImplFileLine),0);
   G__memfunc_setup("ImplFileName",1171,G__EventDict_726_3_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&BigTrack::ImplFileName),0);
   G__memfunc_setup("DeclFileLine",1152,G__EventDict_726_4_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&BigTrack::DeclFileLine),0);
   // automatic copy constructor
   G__memfunc_setup("BigTrack",775,G__EventDict_726_5_1,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_BigTrack),-1,0,1,1,1,0,"u 'BigTrack' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~BigTrack",901,G__EventDict_726_6_1,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,1);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_726_7_1,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_BigTrack),-1,1,1,1,1,0,"u 'BigTrack' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncHistogramManager(void) {
   /* HistogramManager */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__EventDictLN_HistogramManager));
   G__memfunc_setup("HistogramManager",1641,G__EventDict_727_1_0,105,G__get_linked_tagnum(&G__EventDictLN_HistogramManager),-1,0,1,1,1,0,"U 'TDirectory' - 0 - dir",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Hfill",495,G__EventDict_727_2_0,121,-1,-1,0,1,1,1,0,"U 'Event' - 0 - event",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("Class",502,G__EventDict_727_3_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,3,1,0,"",(char*)NULL,(void*)(TClass* (*)())(&HistogramManager::Class),0);
   G__memfunc_setup("Class_Name",982,G__EventDict_727_4_0,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&HistogramManager::Class_Name),0);
   G__memfunc_setup("Class_Version",1339,G__EventDict_727_5_0,115,-1,G__defined_typename("Version_t"),0,0,3,1,0,"",(char*)NULL,(void*)(Version_t (*)())(&HistogramManager::Class_Version),0);
   G__memfunc_setup("Dictionary",1046,G__EventDict_727_6_0,121,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(void (*)())(&HistogramManager::Dictionary),0);
   G__memfunc_setup("IsA",253,G__EventDict_727_7_0,85,G__get_linked_tagnum(&G__EventDictLN_TClass),-1,0,0,1,1,8,"",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("ShowMembers",1132,G__EventDict_727_8_0,121,-1,-1,0,2,1,1,0,
"u 'TMemberInspector' - 1 - insp C - - 0 - parent",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("Streamer",835,G__EventDict_727_9_0,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,1);
   G__memfunc_setup("StreamerNVirtual",1656,G__EventDict_727_0_1,121,-1,-1,0,1,1,1,0,"u 'TBuffer' - 1 - b",(char*)NULL,(void*)NULL,0);
   G__memfunc_setup("DeclFileName",1145,G__EventDict_727_1_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&HistogramManager::DeclFileName),0);
   G__memfunc_setup("ImplFileLine",1178,G__EventDict_727_2_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&HistogramManager::ImplFileLine),0);
   G__memfunc_setup("ImplFileName",1171,G__EventDict_727_3_1,67,-1,-1,0,0,3,1,1,"",(char*)NULL,(void*)(const char* (*)())(&HistogramManager::ImplFileName),0);
   G__memfunc_setup("DeclFileLine",1152,G__EventDict_727_4_1,105,-1,-1,0,0,3,1,0,"",(char*)NULL,(void*)(int (*)())(&HistogramManager::DeclFileLine),0);
   // automatic copy constructor
   G__memfunc_setup("HistogramManager",1641,G__EventDict_727_5_1,(int)('i'),G__get_linked_tagnum(&G__EventDictLN_HistogramManager),-1,0,1,1,1,0,"u 'HistogramManager' - 11 - -",(char*)NULL,(void*)NULL,0);
   // automatic destructor
   G__memfunc_setup("~HistogramManager",1767,G__EventDict_727_6_1,(int)('y'),-1,-1,0,0,1,1,0,"",(char*)NULL,(void*)NULL,1);
   // automatic assignment operator
   G__memfunc_setup("operator=",937,G__EventDict_727_7_1,(int)('u'),G__get_linked_tagnum(&G__EventDictLN_HistogramManager),-1,1,1,1,1,0,"u 'HistogramManager' - 11 - -",(char*)NULL,(void*)NULL,0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncEventDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {
}

static void G__cpp_setup_global3() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalEventDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
  G__cpp_setup_global3();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {
}

static void G__cpp_setup_func26() {
}

static void G__cpp_setup_func27() {
}

static void G__cpp_setup_func28() {
}

static void G__cpp_setup_func29() {
}

static void G__cpp_setup_func30() {
}

static void G__cpp_setup_func31() {
}

static void G__cpp_setup_func32() {
}

static void G__cpp_setup_func33() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcEventDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
  G__cpp_setup_func26();
  G__cpp_setup_func27();
  G__cpp_setup_func28();
  G__cpp_setup_func29();
  G__cpp_setup_func30();
  G__cpp_setup_func31();
  G__cpp_setup_func32();
  G__cpp_setup_func33();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__EventDictLN_TClass = { "TClass" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TBuffer = { "TBuffer" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TMemberInspector = { "TMemberInspector" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__EventDictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TObjArray = { "TObjArray" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TDatime = { "TDatime" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TDirectory = { "TDirectory" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TClonesArray = { "TClonesArray" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TAxis = { "TAxis" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TArrayI = { "TArrayI" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TArrayF = { "TArrayF" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TH1F = { "TH1F" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TRef = { "TRef" , 99 , -1 };
G__linked_taginfo G__EventDictLN_TLorentzVector = { "TLorentzVector" , 99 , -1 };
G__linked_taginfo G__EventDictLN_listlEstringcOallocatorlEstringgRsPgR = { "list<string,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlEshortcOallocatorlEshortgRsPgR = { "vector<short,allocator<short> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlEstringcOallocatorlEstringgRsPgR = { "vector<string,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_UShortVector = { "UShortVector" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR = { "vector<unsigned short,allocator<unsigned short> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<unsigned short,allocator<unsigned short> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_EventHeader = { "EventHeader" , 99 , -1 };
G__linked_taginfo G__EventDictLN_Event = { "Event" , 99 , -1 };
G__linked_taginfo G__EventDictLN_EventcLcLdA = { "Event::$" , 101 , -1 };
G__linked_taginfo G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR = { "vector<long long,allocator<long long> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlElongsPlongcOallocatorlElongsPlonggRsPgRcLcLiteratorgR = { "reverse_iterator<vector<long long,allocator<long long> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR = { "vector<TLine,allocator<TLine> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlETLinecOallocatorlETLinegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TLine,allocator<TLine> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR = { "vector<TObject,allocator<TObject> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlETObjectcOallocatorlETObjectgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TObject,allocator<TObject> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR = { "vector<TNamed,allocator<TNamed> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlETNamedcOallocatorlETNamedgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TNamed,allocator<TNamed> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_dequelETAttLinecOallocatorlETAttLinegRsPgR = { "deque<TAttLine,allocator<TAttLine> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_listlEconstsPTObjectmUcOallocatorlEconstsPTObjectmUgRsPgR = { "list<const TObject*,allocator<const TObject*> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_listlEstringmUcOallocatorlEstringmUgRsPgR = { "list<string*,allocator<string*> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR = { "map<TNamed*,int,less<TNamed*>,allocator<pair<const TNamed*,int> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_template1lEintgR = { "template1<int>" , 115 , -1 };
G__linked_taginfo G__EventDictLN_template2lEtemplate1lEintgRsPgR = { "template2<template1<int> >" , 115 , -1 };
G__linked_taginfo G__EventDictLN_maplETStringcOTListmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTListmUgRsPgRsPgR = { "map<TString,TList*,less<TString>,allocator<pair<const TString,TList*> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplETStringcOTStringmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTStringmUgRsPgRsPgR = { "map<TString,TString*,less<TString>,allocator<pair<const TString,TString*> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplEEventHeadercOTStringmUcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringmUgRsPgRsPgR = { "map<EventHeader,TString*,less<EventHeader>,allocator<pair<const EventHeader,TString*> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplEEventHeadercOTStringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringgRsPgRsPgR = { "map<EventHeader,TString,less<EventHeader>,allocator<pair<const EventHeader,TString> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplEEventHeadercOstringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOstringgRsPgRsPgR = { "map<EventHeader,string,less<EventHeader>,allocator<pair<const EventHeader,string> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplETAxismUcOintcOlesslETAxismUgRcOallocatorlEpairlEconstsPTAxismUcOintgRsPgRsPgR = { "map<TAxis*,int,less<TAxis*>,allocator<pair<const TAxis*,int> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR = { "set<TAxis*,less<TAxis*>,allocator<TAxis*> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_multimaplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR = { "multimap<TNamed*,int,less<TNamed*>,allocator<pair<const TNamed*,int> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_multisetlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR = { "multiset<TAxis*,less<TAxis*>,allocator<TAxis*> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlETAxismUcOallocatorlETAxismUgRsPgR = { "vector<TAxis*,allocator<TAxis*> >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TAxis*,allocator<TAxis*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR = { "vector<vector<TAxis*,allocator<TAxis*> >,allocator<vector<TAxis*,allocator<TAxis*> > > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_reverse_iteratorlEvectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<TAxis*,allocator<TAxis*> >,allocator<vector<TAxis*,allocator<TAxis*> > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR = { "map<string,vector<int,allocator<int> >,less<string>,allocator<pair<const string,vector<int,allocator<int> > > > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_dequelEpairlEfloatcOfloatgRcOallocatorlEpairlEfloatcOfloatgRsPgRsPgR = { "deque<pair<float,float>,allocator<pair<float,float> > >" , 99 , -1 };
G__linked_taginfo G__EventDictLN_Track = { "Track" , 99 , -1 };
G__linked_taginfo G__EventDictLN_BigTrack = { "BigTrack" , 99 , -1 };
G__linked_taginfo G__EventDictLN_HistogramManager = { "HistogramManager" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableEventDict() {
  G__EventDictLN_TClass.tagnum = -1 ;
  G__EventDictLN_TBuffer.tagnum = -1 ;
  G__EventDictLN_TMemberInspector.tagnum = -1 ;
  G__EventDictLN_TObject.tagnum = -1 ;
  G__EventDictLN_string.tagnum = -1 ;
  G__EventDictLN_TObjArray.tagnum = -1 ;
  G__EventDictLN_TString.tagnum = -1 ;
  G__EventDictLN_TDatime.tagnum = -1 ;
  G__EventDictLN_TDirectory.tagnum = -1 ;
  G__EventDictLN_TClonesArray.tagnum = -1 ;
  G__EventDictLN_TAxis.tagnum = -1 ;
  G__EventDictLN_TArrayI.tagnum = -1 ;
  G__EventDictLN_TArrayF.tagnum = -1 ;
  G__EventDictLN_TH1F.tagnum = -1 ;
  G__EventDictLN_TRef.tagnum = -1 ;
  G__EventDictLN_TLorentzVector.tagnum = -1 ;
  G__EventDictLN_listlEstringcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__EventDictLN_vectorlEshortcOallocatorlEshortgRsPgR.tagnum = -1 ;
  G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__EventDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__EventDictLN_vectorlEstringcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__EventDictLN_UShortVector.tagnum = -1 ;
  G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_EventHeader.tagnum = -1 ;
  G__EventDictLN_Event.tagnum = -1 ;
  G__EventDictLN_EventcLcLdA.tagnum = -1 ;
  G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlElongsPlongcOallocatorlElongsPlonggRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlETLinecOallocatorlETLinegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlETObjectcOallocatorlETObjectgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlETNamedcOallocatorlETNamedgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_dequelETAttLinecOallocatorlETAttLinegRsPgR.tagnum = -1 ;
  G__EventDictLN_listlEconstsPTObjectmUcOallocatorlEconstsPTObjectmUgRsPgR.tagnum = -1 ;
  G__EventDictLN_listlEstringmUcOallocatorlEstringmUgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_template1lEintgR.tagnum = -1 ;
  G__EventDictLN_template2lEtemplate1lEintgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplETStringcOTListmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTListmUgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplETStringcOTStringmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTStringmUgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplEEventHeadercOTStringmUcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringmUgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplEEventHeadercOTStringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplEEventHeadercOstringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOstringgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_maplETAxismUcOintcOlesslETAxismUgRcOallocatorlEpairlEconstsPTAxismUcOintgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR.tagnum = -1 ;
  G__EventDictLN_multimaplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_multisetlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR.tagnum = -1 ;
  G__EventDictLN_vectorlETAxismUcOallocatorlETAxismUgRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_reverse_iteratorlEvectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_dequelEpairlEfloatcOfloatgRcOallocatorlEpairlEfloatcOfloatgRsPgRsPgR.tagnum = -1 ;
  G__EventDictLN_Track.tagnum = -1 ;
  G__EventDictLN_BigTrack.tagnum = -1 ;
  G__EventDictLN_HistogramManager.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableEventDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum(&G__EventDictLN_TClass);
   G__get_linked_tagnum(&G__EventDictLN_TBuffer);
   G__get_linked_tagnum(&G__EventDictLN_TMemberInspector);
   G__get_linked_tagnum(&G__EventDictLN_TObject);
   G__get_linked_tagnum(&G__EventDictLN_string);
   G__get_linked_tagnum(&G__EventDictLN_TObjArray);
   G__get_linked_tagnum(&G__EventDictLN_TString);
   G__get_linked_tagnum(&G__EventDictLN_TDatime);
   G__get_linked_tagnum(&G__EventDictLN_TDirectory);
   G__get_linked_tagnum(&G__EventDictLN_TClonesArray);
   G__get_linked_tagnum(&G__EventDictLN_TAxis);
   G__get_linked_tagnum(&G__EventDictLN_TArrayI);
   G__get_linked_tagnum(&G__EventDictLN_TArrayF);
   G__get_linked_tagnum(&G__EventDictLN_TH1F);
   G__get_linked_tagnum(&G__EventDictLN_TRef);
   G__get_linked_tagnum(&G__EventDictLN_TLorentzVector);
   G__get_linked_tagnum(&G__EventDictLN_listlEstringcOallocatorlEstringgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlEshortcOallocatorlEshortgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlEstringcOallocatorlEstringgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_UShortVector),sizeof(UShortVector),-1,296192,"Encapsulated STL vector of UShorts",G__setup_memvarUShortVector,G__setup_memfuncUShortVector);
   G__get_linked_tagnum(&G__EventDictLN_vectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlEunsignedsPshortcOallocatorlEunsignedsPshortgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_EventHeader),sizeof(EventHeader),-1,263424,"Event Header",G__setup_memvarEventHeader,G__setup_memfuncEventHeader);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_Event),sizeof(Event),-1,324864,"Event structure",G__setup_memvarEvent,G__setup_memfuncEvent);
   G__get_linked_tagnum(&G__EventDictLN_EventcLcLdA);
   G__get_linked_tagnum(&G__EventDictLN_vectorlElongsPlongcOallocatorlElongsPlonggRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlElongsPlongcOallocatorlElongsPlonggRsPgRcLcLiteratorgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlETLinecOallocatorlETLinegRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETLinecOallocatorlETLinegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlETObjectcOallocatorlETObjectgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETObjectcOallocatorlETObjectgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlETNamedcOallocatorlETNamedgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETNamedcOallocatorlETNamedgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum(&G__EventDictLN_dequelETAttLinecOallocatorlETAttLinegRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_listlEconstsPTObjectmUcOallocatorlEconstsPTObjectmUgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_listlEstringmUcOallocatorlEstringmUgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_template1lEintgR),sizeof(template1<int>),-1,262144,(char*)NULL,G__setup_memvartemplate1lEintgR,G__setup_memfunctemplate1lEintgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_template2lEtemplate1lEintgRsPgR),sizeof(template2<template1<int> >),-1,262144,(char*)NULL,G__setup_memvartemplate2lEtemplate1lEintgRsPgR,G__setup_memfunctemplate2lEtemplate1lEintgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTListmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTListmUgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplETStringcOTStringmUcOlesslETStringgRcOallocatorlEpairlEconstsPTStringcOTStringmUgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringmUcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringmUgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOTStringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOTStringgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplEEventHeadercOstringcOlesslEEventHeadergRcOallocatorlEpairlEconstsPEventHeadercOstringgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_maplETAxismUcOintcOlesslETAxismUgRcOallocatorlEpairlEconstsPTAxismUcOintgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_setlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_multimaplETNamedmUcOintcOlesslETNamedmUgRcOallocatorlEpairlEconstsPTNamedmUcOintgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_multisetlETAxismUcOlesslETAxismUgRcOallocatorlETAxismUgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlETAxismUcOallocatorlETAxismUgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum(&G__EventDictLN_vectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_reverse_iteratorlEvectorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRcOallocatorlEvectorlETAxismUcOallocatorlETAxismUgRsPgRsPgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum(&G__EventDictLN_maplEstringcOvectorlEintcOallocatorlEintgRsPgRcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum(&G__EventDictLN_dequelEpairlEfloatcOfloatgRcOallocatorlEpairlEfloatcOfloatgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_Track),sizeof(Track),-1,324864,"A track segment",G__setup_memvarTrack,G__setup_memfuncTrack);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_BigTrack),sizeof(BigTrack),-1,324864,"A Big track ",G__setup_memvarBigTrack,G__setup_memfuncBigTrack);
   G__tagtable_setup(G__get_linked_tagnum(&G__EventDictLN_HistogramManager),sizeof(HistogramManager),-1,33792,"Manages all histograms",G__setup_memvarHistogramManager,G__setup_memfuncHistogramManager);
}
extern "C" void G__cpp_setupEventDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupEventDict()");
  G__set_cpp_environmentEventDict();
  G__cpp_setup_tagtableEventDict();

  G__cpp_setup_inheritanceEventDict();

  G__cpp_setup_typetableEventDict();

  G__cpp_setup_memvarEventDict();

  G__cpp_setup_memfuncEventDict();
  G__cpp_setup_globalEventDict();
  G__cpp_setup_funcEventDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncEventDict();
  return;
}
class G__cpp_setup_initEventDict {
  public:
    G__cpp_setup_initEventDict() { G__add_setup_func("EventDict",(G__incsetup)(&G__cpp_setupEventDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initEventDict() { G__remove_setup_func("EventDict"); }
};
G__cpp_setup_initEventDict G__cpp_setup_initializerEventDict;

